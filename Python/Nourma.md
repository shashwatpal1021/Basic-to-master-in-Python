
{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# second Larget element\n",
    "\n",
    "#include <stdio.h>\n",
    "\n",
    "int secondlargest(int a[],int n)\n",
    "{\n",
    "    int largest=0;\n",
    "    int res=-1;\n",
    "    \n",
    "    for(int i=1;i<n;i++)\n",
    "    {\n",
    "        if(a[i]>a[largest])\n",
    "        {\n",
    "            res=largest;\n",
    "            largest=i;\n",
    "        }\n",
    "        else if(a[i]!=a[largest])\n",
    "        {\n",
    "            if(res==-1||a[i]>a[res])\n",
    "            res=i;\n",
    "        }\n",
    "    }\n",
    "    return res;\n",
    "}\n",
    "int main() \n",
    "{\n",
    "    int n;\n",
    "    scanf(\"%d\",&n);\n",
    "    int a[n];\n",
    "    for(int i=0;i<n;i++)\n",
    "    {\n",
    "        scanf(\"%d\",&a[i]);\n",
    "    }\n",
    "    int pos=secondlargest(a,n);\n",
    "    printf(\"%d \",a[pos]);\n",
    "    \n",
    "\treturn 0;\n",
    "    \n",
    "}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# check if an Array is sorted\n",
    "# NAIVE APP\n",
    "\n",
    "import java.util.*;\n",
    "import java.io.*;\n",
    "import java.lang.*;\n",
    "class GFG \n",
    "{ \n",
    "    static boolean isSorted(int arr[], int n)\n",
    "    {\n",
    "    \tfor(int i = 0; i < n; i++)\n",
    "    \t{\n",
    "    \t\tfor(int j = i + 1; j < n; j++)\n",
    "    \t\t{\n",
    "    \t\t\tif(arr[j] < arr[i])\n",
    "    \t\t\t\treturn false;\n",
    "    \t\t}\n",
    "    \t}\n",
    "\n",
    "    \treturn true;\n",
    "    } \n",
    "\n",
    "    public static void main(String args[]) \n",
    "    { \n",
    "       int arr[] = {7, 2, 30, 10}, n = 4;\n",
    "\n",
    "       System.out.println(isSorted(arr, n));\n",
    "    } \n",
    "}\n",
    "\n",
    "# efficient\n",
    "\n",
    "import java.util.*;\n",
    "import java.io.*;\n",
    "import java.lang.*;\n",
    "class GFG \n",
    "{ \n",
    "    static boolean isSorted(int arr[], int n)\n",
    "    {\n",
    "    \tfor(int i = 1; i < n; i++)\n",
    "    \t{\n",
    "    \t    if(arr[i] < arr[i - 1])\n",
    "    \t        return false;\n",
    "    \t}\n",
    "\n",
    "    \treturn true;\n",
    "    } \n",
    "\n",
    "    public static void main(String args[]) \n",
    "    { \n",
    "       int arr[] = {5, 12, 30, 2, 35}, n = 5;\n",
    "\n",
    "       System.out.println(isSorted(arr, n));\n",
    "    } \n",
    "}\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# remove duplicates\n",
    "\n",
    "# naive\n",
    "\n",
    "import java.util.*;\n",
    "import java.io.*;\n",
    "import java.lang.*;\n",
    "class GFG \n",
    "{ \n",
    "    static int remDups(int arr[], int n)\n",
    "    {\n",
    "    \tint temp[] = new int[n];\n",
    "\n",
    "    \ttemp[0] = arr[0];\n",
    "\n",
    "    \tint res = 1;\n",
    "\n",
    "    \tfor(int i = 1; i < n; i++)\n",
    "    \t{\n",
    "    \t\tif(temp[res - 1] != arr[i])\n",
    "    \t\t{\n",
    "    \t\t\ttemp[res] = arr[i];\n",
    "    \t\t\tres++;\n",
    "    \t\t}\n",
    "    \t}\n",
    "\n",
    "    \tfor(int i = 0; i < res; i++)\n",
    "    \t{\n",
    "    \t\tarr[i] = temp[i];\n",
    "    \t}\n",
    "\n",
    "    \treturn res;\n",
    "    }\n",
    "\n",
    "    public static void main(String args[]) \n",
    "    { \n",
    "       int arr[] = {10, 20, 20, 30, 30, 30}, n = 6;\n",
    "\n",
    "       System.out.println(\"Before Removal\");\n",
    "\n",
    "       for(int i = 0; i < n; i++)\n",
    "       {\n",
    "       \t\tSystem.out.print(arr[i]+\" \");\n",
    "       }\n",
    "\n",
    "       System.out.println();\n",
    "\n",
    "       n = remDups(arr, n);\n",
    "\n",
    "       System.out.println(\"After Removal\");\n",
    "\n",
    "       for(int i = 0; i < n; i++)\n",
    "       {\n",
    "       \t\tSystem.out.print(arr[i]+\" \");\n",
    "       }\n",
    "\n",
    "    } \n",
    "\n",
    "}\n",
    "\n",
    "#EFFICIENT\n",
    "\n",
    "import java.util.*;\n",
    "import java.io.*;\n",
    "import java.lang.*;\n",
    "class GFG \n",
    "{ \n",
    "    static int remDups(int arr[], int n)\n",
    "    {\n",
    "    \tint res = 1;\n",
    "\n",
    "    \tfor(int i = 1; i < n; i++)\n",
    "    \t{\n",
    "    \t\tif(arr[res - 1] != arr[i])\n",
    "    \t\t{\n",
    "    \t\t\tarr[res] = arr[i];\n",
    "    \t\t\tres++;\n",
    "    \t\t}\n",
    "    \t}\n",
    "\n",
    "    \treturn res;\n",
    "    }\n",
    "\n",
    "    public static void main(String args[]) \n",
    "    { \n",
    "       int arr[] = {10, 20, 20, 30, 30, 30}, n = 6;\n",
    "\n",
    "       System.out.println(\"Before Removal\");\n",
    "\n",
    "       for(int i = 0; i < n; i++)\n",
    "       {\n",
    "       \t\tSystem.out.print(arr[i]+\" \");\n",
    "       }\n",
    "\n",
    "       System.out.println();\n",
    "\n",
    "       n = remDups(arr, n);\n",
    "\n",
    "       System.out.println(\"After Removal\");\n",
    "\n",
    "       for(int i = 0; i < n; i++)\n",
    "       {\n",
    "       \t\tSystem.out.print(arr[i]+\" \");\n",
    "       }\n",
    "\n",
    "    } \n",
    "\n",
    "}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# left rotate an array by d palce\n",
    "# efficient\n",
    "import java.util.*;\n",
    "import java.io.*;\n",
    "import java.lang.*;\n",
    "class GFG \n",
    "{ \n",
    "    \n",
    "\n",
    "    static void leftRotate(int arr[], int d, int n)\n",
    "    {\n",
    "    \tint temp[] = new int[d];\n",
    "\n",
    "    \tfor(int i = 0; i  < d; i++)\n",
    "    \t{\n",
    "    \t\ttemp[i] = arr[i];\n",
    "    \t}\n",
    "\n",
    "    \tfor(int i = d; i  < n; i++)\n",
    "    \t{\n",
    "    \t\tarr[i - d] = arr[i];\n",
    "    \t}\n",
    "\n",
    "    \tfor(int i = 0; i  < d; i++)\n",
    "    \t{\n",
    "    \t\tarr[n - d + i] = temp[i];\n",
    "    \t}\t\n",
    "    }\n",
    "\n",
    "    public static void main(String args[]) \n",
    "    { \n",
    "       int arr[] = {1, 2, 3, 4, 5}, n = 5, d = 2;\n",
    "\n",
    "       System.out.println(\"Before Rotation\");\n",
    "\n",
    "       for(int i = 0; i < n; i++)\n",
    "       {\n",
    "       \t\tSystem.out.print(arr[i]+\" \");\n",
    "       }\n",
    "\n",
    "       System.out.println();\n",
    "\n",
    "       leftRotate(arr, d, n);\n",
    "\n",
    "       System.out.println(\"After Rotation\");\n",
    "\n",
    "       for(int i = 0; i < n; i++)\n",
    "       {\n",
    "       \t\tSystem.out.print(arr[i]+\" \");\n",
    "       }\n",
    "\n",
    "    } \n",
    "\n",
    "}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Leader in an Array problem\n",
    "\n",
    "navie\n",
    "\n",
    "import java.util.*;\n",
    "import java.io.*;\n",
    "import java.lang.*;\n",
    "class GFG \n",
    "{ \n",
    "    \n",
    "\n",
    "    static void leaders(int arr[], int n)\n",
    "    {\n",
    "    \tfor(int i = 0; i < n; i++)\n",
    "    \t{\n",
    "    \t\tboolean flag = false;\n",
    "\n",
    "    \t\tfor(int j = i + 1; j < n; j++)\n",
    "    \t\t{\n",
    "    \t\t\tif(arr[i] <= arr[j])\n",
    "    \t\t\t{\n",
    "    \t\t\t\tflag = true;\n",
    "    \t\t\t\tbreak;\n",
    "    \t\t\t}\n",
    "    \t\t}\n",
    "\n",
    "    \t\tif(flag == false)\n",
    "    \t\t{\n",
    "    \t\t\tSystem.out.print(arr[i]+\" \");\n",
    "    \t\t}\n",
    "    \t}\n",
    "    }\n",
    "\n",
    "\n",
    "    public static void main(String args[]) \n",
    "    { \n",
    "       int arr[] = {7, 10, 4, 10, 6, 5, 2}, n = 7;\n",
    "\n",
    "       leaders(arr, n);\n",
    "\n",
    "    } \n",
    "\n",
    "}\n",
    "\n",
    "Efficient\n",
    "\n",
    "import java.util.*;\n",
    "import java.io.*;\n",
    "import java.lang.*;\n",
    "class GFG \n",
    "{ \n",
    "    \n",
    "\n",
    "    static void leaders(int arr[], int n)\n",
    "    {\n",
    "    \tint curr_ldr = arr[n - 1];\n",
    "\n",
    "    \tSystem.out.print(curr_ldr+\" \");\n",
    "\n",
    "    \tfor(int i = n - 2; i >= 0; i--)\n",
    "    \t{\n",
    "    \t\tif(curr_ldr < arr[i])\n",
    "    \t\t{\n",
    "    \t\t\tcurr_ldr = arr[i];\n",
    "\n",
    "    \t\t\tSystem.out.print(curr_ldr+\" \");\n",
    "    \t\t}\n",
    "    \t}\n",
    "    }\n",
    "\n",
    "\n",
    "    public static void main(String args[]) \n",
    "    { \n",
    "       int arr[] = {7, 10, 4, 10, 6, 5, 2}, n = 7;\n",
    "\n",
    "       leaders(arr, n);\n",
    "\n",
    "    } \n",
    "\n",
    "}\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "Maximum Difference problem with order\n",
    "\n",
    "\n",
    "import java.util.*;\n",
    "import java.io.*;\n",
    "import java.lang.*;\n",
    "class GFG \n",
    "{ \n",
    "    \n",
    "\n",
    "    static int maxDiff(int arr[], int n)\n",
    "    {\n",
    "    \tint res = arr[1] - arr[0];\n",
    "\n",
    "    \tfor(int i = 0; i < n - 1; i++)\n",
    "    \t{\n",
    "    \t\tfor(int j = i + 1; j < n; j++)\n",
    "    \t\t{\n",
    "    \t\t\tres = Math.max(res, arr[j] - arr[i]);\n",
    "    \t\t}\n",
    "    \t}\n",
    "\n",
    "    \treturn res;\n",
    "    }\n",
    "\n",
    "\n",
    "    public static void main(String args[]) \n",
    "    { \n",
    "       int arr[] = {2, 3, 10, 6, 4, 8, 1}, n = 7;\n",
    "\n",
    "       System.out.println(maxDiff(arr, n));\n",
    "\n",
    "    } \n",
    "\n",
    "}\n",
    "\n",
    "Efficient\n",
    "\n",
    "\n",
    "import java.util.*;\n",
    "import java.io.*;\n",
    "import java.lang.*;\n",
    "class GFG \n",
    "{ \n",
    "    \n",
    "\n",
    "    static int maxDiff(int arr[], int n)\n",
    "    {\n",
    "    \tint res = arr[1] - arr[0], minVal = arr[0];\n",
    "\n",
    "    \tfor(int i = 1; i < n; i++)\n",
    "    \t{\n",
    "    \t\t\n",
    "    \t\t\tres = Math.max(res, arr[i] - minVal);\n",
    "    \t\t\t\n",
    "    \t\t\tminVal = Math.min(minVal, arr[i]);\n",
    "    \t}\n",
    "\n",
    "    \treturn res;\n",
    "    }\n",
    "\n",
    "\n",
    "    public static void main(String args[]) \n",
    "    { \n",
    "       int arr[] = {2, 3, 10, 6, 4, 8, 1}, n = 7;\n",
    "\n",
    "       System.out.println(maxDiff(arr,n));\n",
    "\n",
    "    } \n",
    "\n",
    "}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "frequency in a sorted array\n",
    "\n",
    "import java.util.*;\n",
    "import java.io.*;\n",
    "import java.lang.*;\n",
    "class GFG \n",
    "{ \n",
    "    \n",
    "\n",
    "    static void printFreq(int arr[], int n)\n",
    "    {\n",
    "    \tint freq = 1, i = 1;\n",
    "\n",
    "    \twhile(i < n)\n",
    "    \t{\n",
    "    \t\twhile(i < n && arr[i] == arr[i - 1])\n",
    "    \t\t{\n",
    "    \t\t\tfreq++;\n",
    "    \t\t\ti++;\n",
    "    \t\t}\n",
    "\n",
    "    \t\tSystem.out.println(arr[i - 1] + \" \" + freq);\n",
    "\n",
    "    \t\ti++;\n",
    "    \t\tfreq = 1;\n",
    "    \t}\n",
    "    }\n",
    "\n",
    "\n",
    "    public static void main(String args[]) \n",
    "    { \n",
    "       int arr[] = {10, 10, 20, 30, 30, 30}, n = 6;\n",
    "\n",
    "       printFreq(arr, n);\n",
    "\n",
    "    } \n",
    "\n",
    "}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "stock buy and sell problem\n",
    "\n",
    "import java.util.*;\n",
    "import java.io.*;\n",
    "import java.lang.*;\n",
    "class GFG \n",
    "{ \n",
    "    \n",
    "\n",
    "    static int maxProfit(int price[], int start, int end)\n",
    "    {\n",
    "    \tif(end <= start)\n",
    "    \t\treturn 0;\n",
    "\n",
    "    \tint profit = 0;\n",
    "\n",
    "    \tfor(int i = start; i < end; i++)\n",
    "    \t{\n",
    "    \t\tfor(int j = i + 1; j <= end; j++)\n",
    "    \t\t{\n",
    "    \t\t\tif(price[j] > price[i])\n",
    "    \t\t\t{\n",
    "    \t\t\t\tint curr_profit = price[j] - price[i] \n",
    "    \t\t\t\t\t\t\t\t  + maxProfit(price, start, i - 1)\n",
    "    \t\t\t\t\t\t\t\t  + maxProfit(price, j + 1, end);\n",
    "\n",
    "    \t\t\t\tprofit = Math.max(profit, curr_profit);\n",
    "    \t\t\t}\n",
    "    \t\t}\n",
    "    \t}\n",
    "\n",
    "    \treturn profit;\n",
    "    }\n",
    "\n",
    "\n",
    "    public static void main(String args[]) \n",
    "    { \n",
    "       int arr[] = {1, 5, 3, 8, 12}, n = 5;\n",
    "\n",
    "       System.out.println(maxProfit(arr, 0, n-1));\n",
    "\n",
    "    } \n",
    "\n",
    "}\n",
    "\n",
    "stock buy and sell problem II\n",
    "\n",
    "import java.util.*;\n",
    "import java.io.*;\n",
    "import java.lang.*;\n",
    "class GFG \n",
    "{ \n",
    "    \n",
    "\n",
    "    static int maxProfit(int price[], int n)\n",
    "    {\n",
    "    \tint profit = 0;\n",
    "\n",
    "    \tfor(int i = 1; i < n; i++)\n",
    "    \t{\n",
    "    \t\tif(price[i] > price[i - 1])\n",
    "    \t\t\tprofit += price[i] - price[i -1];\n",
    "    \t}\n",
    "    \n",
    "    \treturn profit;\n",
    "    }\n",
    "\n",
    "\n",
    "    public static void main(String args[]) \n",
    "    { \n",
    "       int arr[] = {1, 5, 3, 8, 12}, n = 5;\n",
    "\n",
    "       System.out.println(maxProfit(arr, n));\n",
    "\n",
    "    } \n",
    "\n",
    "}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    " Trapping Rain water\n",
    " \n",
    " Naive app\n",
    " \n",
    " import java.util.*;\n",
    "import java.io.*;\n",
    "import java.lang.*;\n",
    "class GFG \n",
    "{ \n",
    "    \n",
    "\n",
    "    static int getWater(int arr[], int n)\n",
    "    {\n",
    "    \tint res = 0;\n",
    "\n",
    "    \tfor(int i = 1; i < n - 1; i++)\n",
    "    \t{\n",
    "    \t\tint lMax = arr[i];\n",
    "\n",
    "    \t\tfor(int j = 0; j < i; j++)\n",
    "    \t\t\tlMax = Math.max(lMax, arr[j]);\n",
    "\n",
    "    \t\tint rMax = arr[i];\n",
    "\n",
    "    \t\tfor(int j = i + 1; j < n; j++)\n",
    "    \t\t\trMax = Math.max(rMax, arr[j]);\n",
    "\n",
    "    \t\tres = res + (Math.min(lMax, rMax) - arr[i]);\n",
    "    \t}\n",
    "    \n",
    "    \treturn res;\n",
    "    }\n",
    "\n",
    "\n",
    "    public static void main(String args[]) \n",
    "    { \n",
    "       int arr[] = {3, 0, 1, 2, 5}, n = 5;\n",
    "\n",
    "      System.out.println( getWater(arr, n));\n",
    "\n",
    "    } \n",
    "\n",
    "}\n",
    "\n",
    "\n",
    "Efficient \n",
    "\n",
    "import java.util.*;\n",
    "import java.io.*;\n",
    "import java.lang.*;\n",
    "class GFG \n",
    "{ \n",
    "    \n",
    "\n",
    "    static int getWater(int arr[], int n)\n",
    "    {\n",
    "    \tint res = 0;\n",
    "\n",
    "    \tint lMax[] = new int[n];\n",
    "    \tint rMax[] = new int[n];\n",
    "\n",
    "    \tlMax[0] = arr[0];\n",
    "    \tfor(int i = 1; i < n; i++)\n",
    "    \t\tlMax[i] = Math.max(arr[i], lMax[i - 1]);\n",
    "\n",
    "\n",
    "    \trMax[n - 1] = arr[n - 1];\n",
    "    \tfor(int i = n - 2; i >= 0; i--)\n",
    "    \t\trMax[i] = Math.max(arr[i], rMax[i + 1]);\n",
    "\n",
    "    \tfor(int i = 1; i < n - 1; i++)\n",
    "    \t\tres = res + (Math.min(lMax[i], rMax[i]) - arr[i]);\n",
    "    \t\n",
    "    \treturn res;\n",
    "    }\n",
    "\n",
    "\n",
    "    public static void main(String args[]) \n",
    "    { \n",
    "       int arr[] = {5, 0, 6, 2, 3}, n = 5;\n",
    "\n",
    "      System.out.println( getWater(arr, n));\n",
    "\n",
    "    } \n",
    "\n",
    "}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "Maximum consecutive 1s\n",
    "\n",
    "Naive\n",
    "\n",
    "import java.util.*;\n",
    "import java.io.*;\n",
    "import java.lang.*;\n",
    "class GFG \n",
    "{ \n",
    "    \n",
    "\n",
    "    static int maxConsecutiveOnes(int arr[], int n)\n",
    "    {\n",
    "    \tint res = 0;\n",
    "\n",
    "    \tfor(int i = 0; i < n; i++)\n",
    "    \t{\n",
    "    \t\tint curr = 0;\n",
    "\n",
    "    \t\tfor(int j = i; j < n; j++)\n",
    "    \t\t{\n",
    "    \t\t\tif(arr[j] == 1) curr++;\n",
    "    \t\t\telse break;\n",
    "    \t\t}\n",
    "\n",
    "    \t\tres = Math.max(res, curr);\n",
    "    \t}\n",
    "    \t\n",
    "    \treturn res;\n",
    "    }\n",
    "\n",
    "\n",
    "    public static void main(String args[]) \n",
    "    { \n",
    "       int arr[] = {0, 1, 1, 1, 0, 1, 1}, n = 7;\n",
    "\n",
    "       System.out.println(maxConsecutiveOnes(arr, n));\n",
    "\n",
    "    } \n",
    "\n",
    "}\n",
    "\n",
    "Efficient\n",
    "\n",
    "import java.util.*;\n",
    "import java.io.*;\n",
    "import java.lang.*;\n",
    "class GFG \n",
    "{ \n",
    "    \n",
    "\n",
    "    static int maxConsecutiveOnes(int arr[], int n)\n",
    "    {\n",
    "    \tint res = 0, curr = 0;\n",
    "\n",
    "    \tfor(int i = 0; i < n; i++)\n",
    "    \t{\n",
    "    \t\tif(arr[i] == 0)\n",
    "    \t\t\tcurr = 0;\n",
    "    \t\telse\n",
    "    \t\t{\n",
    "    \t\t\tcurr++;\n",
    "\n",
    "    \t\t\tres = Math.max(res, curr);\n",
    "    \t\t}\n",
    "    \t}\n",
    "    \t\n",
    "    \treturn res;\n",
    "    }\n",
    "\n",
    "\n",
    "    public static void main(String args[]) \n",
    "    { \n",
    "       int arr[] = {0, 1, 1, 0, 1, 1, 1}, n = 7;\n",
    "\n",
    "       System.out.println(maxConsecutiveOnes(arr, n));\n",
    "\n",
    "    } \n",
    "\n",
    "}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "Maximum subarray sum\n",
    "\n",
    "import java.util.*;\n",
    "import java.io.*;\n",
    "import java.lang.*;\n",
    "class GFG \n",
    "{ \n",
    "    \n",
    "\n",
    "    static int maxSum(int arr[], int n)\n",
    "    {\n",
    "    \tint res = arr[0];\n",
    "\n",
    "    \tfor(int i = 0; i < n; i++)\n",
    "    \t{\n",
    "    \t\tint curr = 0;\n",
    "\n",
    "    \t\tfor(int j = i; j < n; j++)\n",
    "    \t\t{\n",
    "    \t\t\tcurr = curr + arr[j];\n",
    "\n",
    "    \t\t\tres = Math.max(res, curr);\n",
    "    \t\t}\n",
    "    \t}\n",
    "    \t\n",
    "    \treturn res;\n",
    "    }\n",
    "\n",
    "\n",
    "    public static void main(String args[]) \n",
    "    { \n",
    "       int arr[] = {1, -2, 3, -1, 2}, n = 5;\n",
    "\n",
    "       System.out.println(maxSum(arr, n));\n",
    "\n",
    "    } \n",
    "\n",
    "}\n",
    "\n",
    "Efficient\n",
    "\n",
    "\n",
    "import java.util.*;\n",
    "import java.io.*;\n",
    "import java.lang.*;\n",
    "class GFG \n",
    "{ \n",
    "    \n",
    "\n",
    "    static int maxSum(int arr[], int n)\n",
    "    {\n",
    "    \tint res = arr[0];\n",
    "\n",
    "    \tint maxEnding = arr[0];\n",
    "\n",
    "    \tfor(int i = 1; i < n; i++)\n",
    "    \t{\n",
    "    \t\tmaxEnding = Math.max(maxEnding + arr[i], arr[i]);\n",
    "\n",
    "    \t\tres = Math.max(maxEnding, res);\n",
    "    \t}\n",
    "    \t\n",
    "    \treturn res;\n",
    "    }\n",
    "\n",
    "\n",
    "    public static void main(String args[]) \n",
    "    { \n",
    "       int arr[] = {1, -2, 3, -1, 2}, n = 5;\n",
    "\n",
    "       System.out.println(maxSum(arr, n));\n",
    "\n",
    "    } \n",
    "\n",
    "}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "longest Even odd subarray\n",
    "\n",
    "naive\n",
    "import java.util.*;\n",
    "import java.io.*;\n",
    "import java.lang.*;\n",
    "class GFG \n",
    "{ \n",
    "    \n",
    "\n",
    "    static int maxEvenOdd(int arr[], int n)\n",
    "    {\n",
    "    \tint res = 1;\n",
    "\n",
    "    \tfor(int i = 0; i < n; i++)\n",
    "    \t{\n",
    "    \t\tint curr = 1;\n",
    "\n",
    "    \t\tfor(int j = i + 1; j < n; j++)\n",
    "    \t\t{\n",
    "    \t\t\tif((arr[j] % 2 == 0 && arr[j - 1] % 2 != 0)\n",
    "    \t\t\t   ||(arr[j] % 2 != 0 && arr[j - 1] % 2 == 0))\n",
    "    \t\t\t\tcurr++;\n",
    "    \t\t\telse\n",
    "    \t\t\t\tbreak;\n",
    "    \t\t}\n",
    "\n",
    "    \t\tres = Math.max(res, curr);\n",
    "    \t}\n",
    "    \t\n",
    "    \treturn res;\n",
    "    }\n",
    "\n",
    "\n",
    "    public static void main(String args[]) \n",
    "    { \n",
    "       int arr[] = {5, 10, 20, 6, 3, 8}, n = 6;\n",
    "\n",
    "       System.out.println(maxEvenOdd(arr, n));\n",
    "\n",
    "    } \n",
    "\n",
    "}\n",
    "\n",
    "Efficient\n",
    "import java.util.*;\n",
    "import java.io.*;\n",
    "import java.lang.*;\n",
    "class GFG \n",
    "{ \n",
    "    \n",
    "\n",
    "    static int maxEvenOdd(int arr[], int n)\n",
    "    {\n",
    "    \tint res = 1;\n",
    "    \tint curr = 1;\n",
    "\n",
    "    \tfor(int i = 1; i < n; i++)\n",
    "    \t{\n",
    "    \t\t\tif((arr[i] % 2 == 0 && arr[i - 1] % 2 != 0)\n",
    "    \t\t\t   ||(arr[i] % 2 != 0 && arr[i - 1] % 2 == 0))\n",
    "    \t\t\t\t{\n",
    "    \t\t\t\t\tcurr++;\n",
    "\n",
    "    \t\t\t\t\tres = Math.max(res, curr);\n",
    "    \t\t\t\t}\n",
    "    \t\t\t\telse\n",
    "    \t\t\t\t\tcurr = 1;\n",
    "    \t}\n",
    "    \t\n",
    "    \treturn res;\n",
    "    }\n",
    "\n",
    "\n",
    "    public static void main(String args[]) \n",
    "    { \n",
    "       int arr[] = {5, 10, 20, 6, 3, 8}, n = 6;\n",
    "\n",
    "       System.out.println(maxEvenOdd(arr, n));\n",
    "\n",
    "    } \n",
    "\n",
    "}\n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "maximum circular sum subarray\n",
    "\n",
    "naive\n",
    "\n",
    "import java.util.*;\n",
    "import java.io.*;\n",
    "import java.lang.*;\n",
    "class GFG \n",
    "{ \n",
    "    \n",
    "\n",
    "    static int maxCircularSum(int arr[], int n)\n",
    "    {\n",
    "    \tint res = arr[0];\n",
    "\n",
    "    \tfor(int i = 0; i < n; i++)\n",
    "    \t{\n",
    "    \t\tint curr_max = arr[i];\n",
    "    \t\tint curr_sum = arr[i];\n",
    "\n",
    "    \t\tfor(int j = 1; j < n; j++)\n",
    "    \t\t{\n",
    "    \t\t\tint index = (i + j) % n;\n",
    "\n",
    "    \t\t\tcurr_sum += arr[index];\n",
    "\n",
    "    \t\t\tcurr_max = Math.max(curr_max, curr_sum);\n",
    "    \t\t}\n",
    "\n",
    "    \t\tres = Math.max(res, curr_max);\n",
    "    \t}\n",
    "    \treturn res;\n",
    "    }\n",
    "\n",
    "\n",
    "    public static void main(String args[]) \n",
    "    { \n",
    "       int arr[] = {5, -2, 3, 4}, n = 4;\n",
    "\n",
    "       System.out.println(maxCircularSum(arr, n));\n",
    "\n",
    "    } \n",
    "\n",
    "}\n",
    "\n",
    "import java.util.*;\n",
    "import java.io.*;\n",
    "import java.lang.*;\n",
    "class GFG \n",
    "{ \n",
    "    static int normalMaxSum(int arr[], int n)\n",
    "    {\n",
    "    \tint res = arr[0];\n",
    "\n",
    "    \tint maxEnding = arr[0];\n",
    "\n",
    "    \tfor(int i = 1; i < n; i++)\n",
    "    \t{\n",
    "    \t\tmaxEnding = Math.max(maxEnding + arr[i], arr[i]);\n",
    "\n",
    "    \t\tres = Math.max(maxEnding, res);\n",
    "    \t}\n",
    "    \t\n",
    "    \treturn res;\n",
    "    }\n",
    "\n",
    "    static int overallMaxSum(int arr[], int n)\n",
    "    {\n",
    "    \tint max_normal = normalMaxSum(arr, n);\n",
    "\n",
    "    \tif(max_normal < 0)\n",
    "    \t\treturn max_normal;\n",
    "\n",
    "    \tint arr_sum = 0;\n",
    "\n",
    "    \tfor(int i = 0; i < n; i++)\n",
    "    \t{\n",
    "    \t\tarr_sum += arr[i];\n",
    "\n",
    "    \t\tarr[i] = -arr[i];\n",
    "    \t}\n",
    "\n",
    "    \tint max_circular = arr_sum + normalMaxSum(arr, n);\n",
    "\n",
    "    \treturn Math.max(max_circular, max_normal);\n",
    "    }\n",
    "\n",
    "\n",
    "    public static void main(String args[]) \n",
    "    { \n",
    "       int arr[] = {8, -4, 3, -5, 4}, n = 5;\n",
    "\n",
    "       System.out.println(overallMaxSum(arr, n));\n",
    "\n",
    "    } \n",
    "\n",
    "}\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "Majority Element\n",
    "\n",
    "naive\n",
    "import java.util.*;\n",
    "import java.io.*;\n",
    "import java.lang.*;\n",
    "class GFG \n",
    "{ \n",
    "\n",
    "    static int findMajority(int arr[], int n)\n",
    "    {\n",
    "    \tfor(int i = 0; i < n; i++)\n",
    "    \t{\n",
    "    \t\tint count = 1;\n",
    "\n",
    "    \t\tfor(int j = i + 1; j < n; j++)\n",
    "    \t\t{\n",
    "    \t\t\tif(arr[i] == arr[j])\n",
    "    \t\t\t\tcount++;\n",
    "    \t\t}\n",
    "\n",
    "    \t\tif(count > n / 2)\n",
    "    \t\t\treturn i;\n",
    "    \t}\n",
    "\n",
    "    \treturn -1;\n",
    "    }\n",
    "\n",
    "\n",
    "    public static void main(String args[]) \n",
    "    { \n",
    "       int arr[] = {8, 7, 6, 8, 6, 6, 6, 6}, n = 8;\n",
    "\n",
    "       System.out.println(findMajority(arr, n));\n",
    "\n",
    "    } \n",
    "\n",
    "}\n",
    "Efficient\n",
    "\n",
    "import java.util.*;\n",
    "import java.io.*;\n",
    "import java.lang.*;\n",
    "class GFG \n",
    "{ \n",
    "\n",
    "    static int findMajority(int arr[], int n)\n",
    "    {\n",
    "    \tint res = 0, count = 1;\n",
    "\n",
    "    \tfor(int i = 1; i < n; i++)\n",
    "    \t{\n",
    "    \t\tif(arr[res] == arr[i])\n",
    "    \t\t\tcount++;\n",
    "    \t\telse \n",
    "    \t\t\tcount --;\n",
    "\n",
    "    \t\tif(count == 0)\n",
    "    \t\t{\n",
    "    \t\t\tres = i; count = 1;\n",
    "    \t\t}\n",
    "    \t}\n",
    "\n",
    "    \tcount = 0;\n",
    "\n",
    "    \tfor(int i = 0; i < n; i++)\n",
    "    \t\tif(arr[res] == arr[i])\n",
    "    \t\t\tcount++;\n",
    "\n",
    "    \tif(count <= n /2)\n",
    "    \t\tres = -1;\n",
    "\n",
    "    \treturn res; \n",
    "    }\n",
    "\n",
    "\n",
    "    public static void main(String args[]) \n",
    "    { \n",
    "       int arr[] = {8, 8, 6, 6, 6, 4, 6}, n = 7;\n",
    "\n",
    "       System.out.println(findMajority(arr, n));\n",
    "\n",
    "    } \n",
    "\n",
    "}\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "minimum consecutive flips\n",
    "import java.util.*;\n",
    "import java.io.*;\n",
    "import java.lang.*;\n",
    "class GFG \n",
    "{ \n",
    "\n",
    "    static void printGroups(int arr[], int n)\n",
    "    {\n",
    "    \tfor(int i = 1; i < n; i++)\n",
    "    \t{\n",
    "    \t\tif(arr[i] != arr[i - 1])\n",
    "    \t\t{\n",
    "    \t\t\tif(arr[i] != arr[0])\n",
    "                    System.out.print(\"From \" + i + \" to \");\n",
    "    \t\t\telse\n",
    "                    System.out.println(i - 1);\n",
    "    \t\t}\n",
    "    \t}\n",
    "\n",
    "    \tif(arr[n - 1] != arr[0])\n",
    "            System.out.println(n-1);\n",
    "    }\n",
    "\n",
    "\n",
    "    public static void main(String args[]) \n",
    "    { \n",
    "       int arr[] = {0, 0, 1, 1, 0, 0, 1, 1, 0}, n = 9;\n",
    "\n",
    "       printGroups(arr, n);\n",
    "\n",
    "    } \n",
    "\n",
    "}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "Sliding window technique\n",
    "\n",
    "1.maximum sum of k consecutive elements\n",
    "\n",
    "naive\n",
    "\n",
    "import java.util.*;\n",
    "import java.io.*;\n",
    "import java.lang.*;\n",
    "class GFG \n",
    "{ \n",
    "\n",
    "    static int maxSum(int arr[], int n, int k)\n",
    "    {\n",
    "    \tint max_sum = Integer.MIN_VALUE;\n",
    "    \tfor(int i = 0; i + k - 1 < n; i++)\n",
    "    \t{\n",
    "    \t\tint sum = 0;\n",
    "\n",
    "    \t\tfor(int j = 0; j < k; j++)\n",
    "    \t\t{\n",
    "    \t\t\tsum += arr[i + j];\n",
    "    \t\t}\n",
    "\n",
    "    \t\tmax_sum = Math.max(max_sum, sum);\n",
    "    \t}\n",
    "\n",
    "    \treturn max_sum;\n",
    "\n",
    "    }\n",
    "\n",
    "\n",
    "    public static void main(String args[]) \n",
    "    { \n",
    "       int arr[] = {1, 8, 30, -5, 20, 7}, n = 6, k = 3;\n",
    "\n",
    "       System.out.println(maxSum(arr, n, k));\n",
    "\n",
    "    } \n",
    "\n",
    "}\n",
    "Efficient\n",
    "\n",
    "import java.util.*;\n",
    "import java.io.*;\n",
    "import java.lang.*;\n",
    "class GFG \n",
    "{ \n",
    "\n",
    "    static int maxSum(int arr[], int n, int k)\n",
    "    {\n",
    "    \tint curr_sum = 0;\n",
    "\n",
    "    \tfor(int i = 0; i < k; i++)\n",
    "    \t\tcurr_sum += arr[i];\n",
    "\n",
    "    \tint max_sum = curr_sum;\n",
    "\n",
    "    \tfor(int i = k; i < n; i++)\n",
    "    \t{\n",
    "    \t\tcurr_sum += (arr[i] - arr[i - k]);\n",
    "\n",
    "    \t\tmax_sum = Math.max(max_sum, curr_sum);\n",
    "    \t}\n",
    "\n",
    "    \treturn max_sum;\n",
    "    }\n",
    "\n",
    "\n",
    "    public static void main(String args[]) \n",
    "    { \n",
    "       int arr[] = {1, 8, 30, -5, 20, 7}, n = 6, k = 3;\n",
    "\n",
    "       System.out.println(maxSum(arr, n, k));\n",
    "\n",
    "    } \n",
    "\n",
    "}\n",
    "\n",
    "\n",
    "2. Find subarray with given sum\n",
    "\n",
    "class SubarraySum \n",
    "{ \n",
    "\t/* Returns true if the there is a subarray of arr[] with sum equal to \n",
    "\t'sum' otherwise returns false. Also, prints the result */\n",
    "\tint subArraySum(int arr[], int n, int sum) \n",
    "\t{ \n",
    "\t\tint curr_sum = arr[0], start = 0, i; \n",
    "\n",
    "\t\t// Pick a starting point \n",
    "\t\tfor (i = 1; i <= n; i++) \n",
    "\t\t{ \n",
    "\t\t\t// If curr_sum exceeds the sum, then remove the starting elements \n",
    "\t\t\twhile (curr_sum > sum && start < i-1) \n",
    "\t\t\t{ \n",
    "\t\t\t\tcurr_sum = curr_sum - arr[start]; \n",
    "\t\t\t\tstart++; \n",
    "\t\t\t} \n",
    "\t\t\t\n",
    "\t\t\t// If curr_sum becomes equal to sum, then return true \n",
    "\t\t\tif (curr_sum == sum) \n",
    "\t\t\t{ \n",
    "\t\t\t\tint p = i-1; \n",
    "\t\t\t\tSystem.out.println(\"Sum found between indexes \" + start \n",
    "\t\t\t\t\t\t+ \" and \" + p); \n",
    "\t\t\t\treturn 1; \n",
    "\t\t\t} \n",
    "\t\t\t\n",
    "\t\t\t// Add this element to curr_sum \n",
    "\t\t\tif (i < n) \n",
    "\t\t\tcurr_sum = curr_sum + arr[i]; \n",
    "\t\t\t\n",
    "\t\t} \n",
    "\n",
    "\t\tSystem.out.println(\"No subarray found\"); \n",
    "\t\treturn 0; \n",
    "\t} \n",
    "\n",
    "\tpublic static void main(String[] args) \n",
    "\t{ \n",
    "\t\tSubarraySum arraysum = new SubarraySum(); \n",
    "\t\tint arr[] = {15, 2, 4, 8, 9, 5, 10, 23}; \n",
    "\t\tint n = arr.length; \n",
    "\t\tint sum = 23; \n",
    "\t\tarraysum.subArraySum(arr, n, sum); \n",
    "\t} \n",
    "} \n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "prefix sum array\n",
    "\n",
    "import java.util.*;\n",
    "import java.io.*;\n",
    "import java.lang.*;\n",
    "class GFG \n",
    "{ \n",
    "\n",
    "    static int[] preSum(int arr[], int n)\n",
    "    {\n",
    "    \t\n",
    "    \tint prefix_sum[] = new int[n];\n",
    "\n",
    "    \tprefix_sum[0] = arr[0];\n",
    "\n",
    "    \tfor(int i = 1; i < n; i++)\n",
    "    \t{\n",
    "    \t\tprefix_sum[i] = prefix_sum[i - 1] + arr[i];\n",
    "    \t}\n",
    "    \t\n",
    "    \treturn prefix_sum;\n",
    "    }\n",
    "\n",
    "    static int getSum(int prefix_sum[], int l, int r)\n",
    "    {\n",
    "    \tif(l != 0)\n",
    "    \t\treturn prefix_sum[r] - prefix_sum[l - 1];\n",
    "    \telse\n",
    "    \t\treturn prefix_sum[r];\n",
    "    }\n",
    "    \n",
    "    \n",
    "    public static void main(String args[]) \n",
    "    { \n",
    "       int arr[] = {2, 8, 3, 9, 6, 5, 4}, n = 7;\n",
    "\n",
    "       int prefix_sum[] = preSum(arr, n);\n",
    "\n",
    "       System.out.println(getSum(prefix_sum, 1, 3));\n",
    "       \n",
    "       System.out.println(getSum(prefix_sum, 0, 2));\n",
    "       \n",
    "    } \n",
    "\n",
    "}\n",
    "\n",
    "\n",
    "2. Equilibrium point\n",
    "naive\n",
    "\n",
    "import java.util.*;\n",
    "import java.io.*;\n",
    "import java.lang.*;\n",
    "class GFG \n",
    "{ \n",
    "\n",
    "  \n",
    "    static boolean checkEquilibrium(int arr[], int n)\n",
    "    {\n",
    "    \tfor(int i  = 0; i < n; i++)\n",
    "    \t{\n",
    "    \t\tint l_sum = 0, r_sum = 0;\n",
    "\n",
    "    \t\tfor(int j = 0; j < i; j++)\n",
    "    \t\t\tl_sum += arr[j];\n",
    "\n",
    "    \t\tfor(int j = i + 1; j < n; j++)\n",
    "    \t\t\tr_sum += arr[j];\n",
    "\n",
    "    \t\tif(l_sum == r_sum)\n",
    "    \t\t\treturn true;\n",
    "    \t}\n",
    "\n",
    "    \treturn false;\n",
    "    }\n",
    "    public static void main(String args[]) \n",
    "    { \n",
    "       int arr[] = {3, 4, 8, -9, 20, 6}, n = 6;\n",
    "\n",
    "       System.out.println(checkEquilibrium(arr, n));\n",
    "\n",
    "    } \n",
    "\n",
    "}\n",
    "Efficient\n",
    "\n",
    "import java.util.*;\n",
    "import java.io.*;\n",
    "import java.lang.*;\n",
    "class GFG \n",
    "{ \n",
    "\n",
    "  \n",
    "    static boolean checkEquilibrium(int arr[], int n)\n",
    "    {\n",
    "    \tint sum = 0;\n",
    "\n",
    "    \tfor(int i = 0; i < n; i++)\n",
    "    \t{\n",
    "    \t\tsum += arr[i];\n",
    "    \t}\n",
    "\n",
    "    \tint l_sum = 0;\n",
    "\n",
    "    \tfor(int i = 0; i < n; i++)\n",
    "    \t{\n",
    "    \t\tif(l_sum == sum - arr[i])\n",
    "    \t\t\treturn true;\n",
    "\n",
    "    \t\tl_sum += arr[i];\n",
    "\n",
    "    \t\tsum -= arr[i];\n",
    "    \t}\n",
    "\n",
    "    \treturn false;\n",
    "    }\n",
    "    public static void main(String args[]) \n",
    "    { \n",
    "       int arr[] = {3, 4, 8, -9, 20, 6}, n = 6;\n",
    "\n",
    "       System.out.println(checkEquilibrium(arr, n));\n",
    "\n",
    "    } \n",
    "\n",
    "}\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "maximum occuring element\n",
    "import java.util.*;\n",
    "import java.io.*;\n",
    "import java.lang.*;\n",
    "class GFG \n",
    "{ \n",
    "\n",
    "\n",
    "    static int maxOcc(int L[], int R[], int n)\n",
    "    {\t\n",
    "\t    \tint arr[] = new int[1000];\n",
    "\n",
    "\t    \tfor(int i = 0; i < n; i++)\n",
    "\t    \t{\n",
    "\t    \t\tarr[L[i]]++;\n",
    "\n",
    "\t    \t\tarr[R[i] + 1]--;\n",
    "\t    \t}\n",
    "\n",
    "\t    \tint maxm = arr[0], res = 0;\n",
    "\n",
    "\t    \tfor(int i = 1; i < 1000; i++)\n",
    "\t    \t{\n",
    "\t    \t\tarr[i] += arr[i - 1];\n",
    "\n",
    "\t    \t\tif(maxm < arr[i])\n",
    "\t    \t\t{\n",
    "\t    \t\t\tmaxm = arr[i];\n",
    "\n",
    "\t    \t\t\tres = i;\n",
    "\t    \t\t}\n",
    "\t    \t}\n",
    "\n",
    "\t    \treturn res;\n",
    "    }\n",
    "    public static void main(String args[]) \n",
    "    { \n",
    "       int L[] = {1, 2, 3}, R[] = {3, 5, 7}, n = 3;\n",
    "\n",
    "      System.out.println(maxOcc(L, R, n)); \n",
    "      \n",
    "    } \n",
    "\n",
    "}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "#searching\n",
    "\n",
    "Binary search\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "1st occurrence in sorted\n",
    "naive\n",
    "import java.util.*;\n",
    "import java.io.*;\n",
    "import java.lang.*;\n",
    "\n",
    "\n",
    "\n",
    "class GFG \n",
    "{ \n",
    "\t\n",
    "\t\n",
    "\n",
    "\tstatic int firstOccurrence(int arr[], int n, int x)\n",
    "\t{\n",
    "\t\tfor(int i = 0; i < n; i++)\n",
    "\t\t\tif(arr[i] == x)\n",
    "\t\t\t\treturn i;\n",
    "\n",
    "\t\treturn -1;\n",
    "\t}\n",
    "\n",
    "\tpublic static void main(String args[]) \n",
    "    {\n",
    "        int arr[] = {5, 10, 10, 15, 15}, n = 5;\n",
    "\n",
    "\t\tint x = 15;\n",
    "    \n",
    "        System.out.println(firstOccurrence(arr, n, x));\n",
    "\t\t\n",
    "    } \n",
    "\n",
    "}\n",
    "efficient recursive\n",
    "import java.util.*;\n",
    "import java.io.*;\n",
    "import java.lang.*;\n",
    "\n",
    "\n",
    "\n",
    "class GFG \n",
    "{ \n",
    "\t\n",
    "\t\n",
    "\n",
    "\tstatic int firstOcc(int arr[], int low, int high, int x)\n",
    "\t{\n",
    "\t\tif(low > high)\n",
    "\t\t\treturn -1;\n",
    "\n",
    "\t\tint mid = (low + high) / 2;\n",
    "\n",
    "\t\tif(x > arr[mid])\n",
    "\t\t\treturn firstOcc(arr, mid + 1, high, x);\n",
    "\n",
    "\t\telse if(x < arr[mid])\n",
    "\t\t\treturn firstOcc(arr, low, mid - 1, x);\n",
    "\n",
    "\t\telse\n",
    "\t\t{\n",
    "\t\t\tif(mid == 0 || arr[mid - 1] != arr[mid])\n",
    "\t\t\t\treturn mid;\n",
    "\n",
    "\t\t\telse\n",
    "\t\t\t\treturn firstOcc(arr, low, mid - 1, x);\n",
    "\t\t}\n",
    "\t}\n",
    "\n",
    "\tpublic static void main(String args[]) \n",
    "    {\n",
    "        int arr[] = {5, 10, 10, 15, 20, 20, 20}, n = 7;\n",
    "\n",
    "\t\tint x = 20;\n",
    "\t\t\n",
    "\t\tSystem.out.println(firstOcc(arr, 0, n - 1, x));\n",
    "\n",
    "\n",
    "    } \n",
    "\n",
    "}\n",
    "efficient iterative \n",
    "import java.util.*;\n",
    "import java.io.*;\n",
    "import java.lang.*;\n",
    "\n",
    "\n",
    "\n",
    "class GFG \n",
    "{ \n",
    "\t\n",
    "\t\n",
    "\n",
    "\tstatic int firstOcc(int arr[], int n, int x)\n",
    "\t{\n",
    "\t\tint low = 0, high = n - 1;\n",
    "\n",
    "\t\twhile(low <= high)\n",
    "\t\t{\n",
    "\t\t\tint mid = (low + high) / 2;\n",
    "\n",
    "\t\t\tif(x > arr[mid])\n",
    "\t\t\t\tlow = mid + 1;\n",
    "\n",
    "\t\t\telse if(x < arr[mid])\n",
    "\t\t\t\thigh = mid - 1;\n",
    "\n",
    "\t\t\telse\n",
    "\t\t\t{\n",
    "\t\t\t\tif(mid == 0 || arr[mid - 1] != arr[mid])\n",
    "\t\t\t\t\treturn mid;\n",
    "\n",
    "\t\t\t\telse\n",
    "\t\t\t\t\thigh = mid - 1;\n",
    "\t\t\t}\n",
    "\n",
    "\t\t}\n",
    "\n",
    "\t\treturn -1;\n",
    "\t}\n",
    "\n",
    "\tpublic static void main(String args[]) \n",
    "    {\n",
    "        int arr[] = {5, 10, 10, 10, 20}, n = 5;\n",
    "\n",
    "\t\tint x = 10;\n",
    "\n",
    "        System.out.println(firstOcc(arr, n, x));\n",
    "    } \n",
    "\n",
    "}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "index of last occurrence in sorted\n",
    "\n",
    "iterative\n",
    "import java.util.*;\n",
    "import java.io.*;\n",
    "import java.lang.*;\n",
    "\n",
    "\n",
    "\n",
    "class GFG \n",
    "{ \n",
    "\t\n",
    "\t\n",
    "\n",
    "\tstatic int lastOcc(int arr[], int n, int x)\n",
    "\t{\n",
    "\t\tint low = 0, high = n - 1;\n",
    "\n",
    "\t\twhile(low <= high)\n",
    "\t\t{\n",
    "\t\t\tint mid = (low + high) / 2;\n",
    "\n",
    "\t\t\tif(x > arr[mid])\n",
    "\t\t\t\tlow = mid + 1;\n",
    "\n",
    "\t\t\telse if(x < arr[mid])\n",
    "\t\t\t\thigh = mid - 1;\n",
    "\n",
    "\t\t\telse\n",
    "\t\t\t{\n",
    "\t\t\t\tif(mid == n - 1 || arr[mid + 1] != arr[mid])\n",
    "\t\t\t\t\treturn mid;\n",
    "\n",
    "\t\t\t\telse\n",
    "\t\t\t\t\tlow = mid + 1;\n",
    "\t\t\t}\n",
    "\n",
    "\t\t}\n",
    "\n",
    "\t\treturn -1;\n",
    "\t}\n",
    "\n",
    "\n",
    "\tpublic static void main(String args[]) \n",
    "    {\n",
    "        int arr[] = {5, 10, 10, 10, 10, 20, 20}, n = 7;\n",
    "\n",
    "\t\tint x = 10;\n",
    "\n",
    "\t\tSystem.out.println(lastOcc(arr, n, x));\n",
    "\n",
    "    } \n",
    "\n",
    "\n",
    "}\n",
    "\n",
    "recurrsive\n",
    "import java.util.*;\n",
    "import java.io.*;\n",
    "import java.lang.*;\n",
    "\n",
    "\n",
    "\n",
    "class GFG \n",
    "{ \n",
    "\t\n",
    "\t\n",
    "\n",
    "\tstatic int lastOcc(int arr[], int low, int high, int x, int n)\n",
    "\t{\n",
    "\t\tif(low > high)\n",
    "\t\t\treturn -1;\n",
    "\n",
    "\t\tint mid = (low + high) / 2;\n",
    "\n",
    "\t\tif(x > arr[mid])\n",
    "\t\t\treturn lastOcc(arr, mid + 1, high, x, n);\n",
    "\n",
    "\t\telse if(x < arr[mid])\n",
    "\t\t\treturn lastOcc(arr, low, mid - 1, x, n);\n",
    "\n",
    "\t\telse\n",
    "\t\t{\n",
    "\t\t\tif(mid == n - 1 || arr[mid + 1] != arr[mid])\n",
    "\t\t\t\treturn mid;\n",
    "\n",
    "\t\t\telse\n",
    "\t\t\t\treturn lastOcc(arr, mid + 1, high, x, n);\n",
    "\t\t}\n",
    "\t}\n",
    "\n",
    "\tpublic static void main(String args[]) \n",
    "    {\n",
    "        int arr[] = {5, 10, 10, 10, 10, 20, 20}, n = 7;\n",
    "\n",
    "\t\tint x = 10;\n",
    "\n",
    "        System.out.println(lastOcc(arr, 0, n - 1, x, n));\n",
    "    } \n",
    "\n",
    "}\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "count occurrence\n",
    "import java.util.*;\n",
    "import java.io.*;\n",
    "import java.lang.*;\n",
    "\n",
    "\n",
    "\n",
    "class GFG \n",
    "{ \n",
    "\t\n",
    "\tstatic int firstOcc(int arr[], int n, int x)\n",
    "\t{\n",
    "\t\tint low = 0, high = n - 1;\n",
    "\n",
    "\t\twhile(low <= high)\n",
    "\t\t{\n",
    "\t\t\tint mid = (low + high) / 2;\n",
    "\n",
    "\t\t\tif(x > arr[mid])\n",
    "\t\t\t\tlow = mid + 1;\n",
    "\n",
    "\t\t\telse if(x < arr[mid])\n",
    "\t\t\t\thigh = mid - 1;\n",
    "\n",
    "\t\t\telse\n",
    "\t\t\t{\n",
    "\t\t\t\tif(mid == 0 || arr[mid - 1] != arr[mid])\n",
    "\t\t\t\t\treturn mid;\n",
    "\n",
    "\t\t\t\telse\n",
    "\t\t\t\t\thigh = mid - 1;\n",
    "\t\t\t}\n",
    "\n",
    "\t\t}\n",
    "\n",
    "\t\treturn -1;\n",
    "\t}\n",
    "\n",
    "\tstatic int lastOcc(int arr[], int n, int x)\n",
    "\t{\n",
    "\t\tint low = 0, high = n - 1;\n",
    "\n",
    "\t\twhile(low <= high)\n",
    "\t\t{\n",
    "\t\t\tint mid = (low + high) / 2;\n",
    "\n",
    "\t\t\tif(x > arr[mid])\n",
    "\t\t\t\tlow = mid + 1;\n",
    "\n",
    "\t\t\telse if(x < arr[mid])\n",
    "\t\t\t\thigh = mid - 1;\n",
    "\n",
    "\t\t\telse\n",
    "\t\t\t{\n",
    "\t\t\t\tif(mid == n - 1 || arr[mid + 1] != arr[mid])\n",
    "\t\t\t\t\treturn mid;\n",
    "\n",
    "\t\t\t\telse\n",
    "\t\t\t\t\tlow = mid + 1;\n",
    "\t\t\t}\n",
    "\n",
    "\t\t}\n",
    "\n",
    "\t\treturn -1;\n",
    "\t}\n",
    "\t\n",
    "\t\n",
    "\tstatic int countOcc(int arr[], int n, int x)\n",
    "\t{\n",
    "\t\tint first = firstOcc(arr, n, x);\n",
    "\n",
    "\t\tif(first == -1)\n",
    "\t\t\treturn 0;\n",
    "\t\telse \n",
    "\t\t\treturn lastOcc(arr, n, x) - first + 1;\n",
    "\t}\n",
    "\n",
    "\tpublic static void main(String args[]) \n",
    "    {\n",
    "        int arr[] = {10, 20, 20, 20, 40, 40}, n = 6;\n",
    "\n",
    "\t\tint x = 20;\n",
    "\n",
    "\t\tSystem.out.println(countOcc(arr, n, x));\n",
    "\n",
    "    } \n",
    "\n",
    "}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "count 1s in a sorted binary array\n",
    "\n",
    "import java.util.*;\n",
    "import java.io.*;\n",
    "import java.lang.*;\n",
    "\n",
    "\n",
    "\n",
    "class GFG \n",
    "{ \n",
    "\t\n",
    "\n",
    "\tstatic int countOnes(int arr[], int n)\n",
    "\t{\n",
    "\t\tint low = 0, high = n - 1;\n",
    "\n",
    "\t\twhile(low <= high)\n",
    "\t\t{\n",
    "\t\t\tint mid = (low + high) / 2;\n",
    "\n",
    "\t\t\tif(arr[mid] == 0)\n",
    "\t\t\t\tlow = mid + 1;\n",
    "\t\t\telse\n",
    "\t\t\t{\n",
    "\t\t\t\tif(mid == 0 || arr[mid - 1] == 0)\n",
    "\t\t\t\t\treturn (n - mid);\n",
    "\t\t\t\telse \n",
    "\t\t\t\t\thigh = mid -1;\n",
    "\t\t\t}\n",
    "\t\t}\n",
    "\n",
    "\t\treturn 0;\t\t\n",
    "\t}\n",
    "\n",
    "\tpublic static void main(String args[]) \n",
    "    {\n",
    "        int arr[] = {0, 0, 1, 1, 1, 1}, n = 6;\n",
    "\n",
    "\n",
    "\t\tSystem.out.println(countOnes(arr, n));\n",
    "\n",
    "    } \n",
    "\n",
    "}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "square root\n",
    "naive\n",
    "import java.util.*;\n",
    "import java.io.*;\n",
    "import java.lang.*;\n",
    "\n",
    "\n",
    "\n",
    "class GFG \n",
    "{ \n",
    "\t\n",
    "\n",
    "\tstatic int sqRootFloor(int x)\n",
    "\t{\n",
    "\t\tint i = 1;\n",
    "\n",
    "\t\twhile(i * i <= x)\n",
    "\t\t\ti++;\n",
    "\n",
    "\t\treturn i - 1;\n",
    "\t}\n",
    "\n",
    "\tpublic static void main(String args[]) \n",
    "    {\n",
    "\n",
    "\t\tSystem.out.println(sqRootFloor(15));\n",
    "\n",
    "    } \n",
    "\n",
    "}\n",
    "efficient\n",
    "import java.util.*;\n",
    "import java.io.*;\n",
    "import java.lang.*;\n",
    "\n",
    "\n",
    "\n",
    "class GFG \n",
    "{ \n",
    "\t\n",
    "\n",
    "\tstatic int sqRootFloor(int x)\n",
    "\t{\n",
    "\t\tint low = 1, high = x, ans = -1;\n",
    "\n",
    "\t\twhile(low <= high)\n",
    "\t\t{\n",
    "\t\t\tint mid = (low + high) / 2;\n",
    "\n",
    "\t\t\tint mSq = mid * mid;\n",
    "\n",
    "\t\t\tif(mSq == x)\n",
    "\t\t\t\treturn mid;\n",
    "\t\t\telse if(mSq > x)\n",
    "\t\t\t\thigh = mid - 1;\n",
    "\t\t\telse\n",
    "\t\t\t{\n",
    "\t\t\t\tlow = mid + 1;\n",
    "\t\t\t\tans = mid;\n",
    "\t\t\t}\n",
    "\t\t}\n",
    "\n",
    "\t\treturn ans;\n",
    "\t}\n",
    "\n",
    "\tpublic static void main(String args[]) \n",
    "    {\n",
    "\n",
    "\t\tSystem.out.println(sqRootFloor(10));\n",
    "\n",
    "    } \n",
    "\n",
    "}\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "search in infinite sized array\n",
    "\n",
    "naive\n",
    "import java.util.*;\n",
    "import java.io.*;\n",
    "import java.lang.*;\n",
    "\n",
    "\n",
    "\n",
    "class GFG \n",
    "{ \n",
    "\t\n",
    "\n",
    "\tstatic int search(int arr[], int x)\n",
    "\t{\n",
    "\t\tint i = 0;\n",
    "\n",
    "\t\twhile(true)\n",
    "\t\t{\n",
    "\t\t\tif(arr[i] == x) return i;\n",
    "\n",
    "\t\t\tif(arr[i] > x) return -1;\n",
    "\n",
    "\t\t\ti++;\n",
    "\t\t}\n",
    "\t}\n",
    "\n",
    "\tpublic static void main(String args[]) \n",
    "    {\n",
    "\n",
    "\t\tint arr[] = {1, 2, 3, 5, 5};\n",
    "\n",
    "\t\tint x = 4;\n",
    "\n",
    "\t\tSystem.out.println(search(arr, x));\n",
    "\n",
    "    } \n",
    "\n",
    "}\n",
    "Efficient\n",
    "import java.util.*;\n",
    "import java.io.*;\n",
    "import java.lang.*;\n",
    "\n",
    "\n",
    "\n",
    "class GFG \n",
    "{ \n",
    "\t\tstatic int bSearch(int arr[], int low, int high, int x)\n",
    "\t\t{\n",
    "\t\t\tif(low > high)\n",
    "\t\t\t\treturn -1;\n",
    "\n",
    "\t\t\tint mid = (low + high) / 2;\n",
    "\n",
    "\t\t\tif(arr[mid] == x)\n",
    "\t\t\t\treturn mid;\n",
    "\n",
    "\t\t\telse if(arr[mid] > x)\n",
    "\t\t\t\treturn bSearch(arr, low, mid - 1, x);\n",
    "\n",
    "\t\t\telse\n",
    "\t\t\t\treturn bSearch(arr, mid + 1, high, x);\n",
    "\t\t}\n",
    "\n",
    "\tstatic int search(int arr[], int x)\n",
    "\t{\n",
    "\t\tif(arr[0] == x) return 0;\n",
    "\n",
    "\t\tint i = 1;\n",
    "\n",
    "\t\twhile(arr[i] < x)\n",
    "\t\t\ti = i * 2;\n",
    "\n",
    "\t\tif(arr[i] == x) return i;\n",
    "\n",
    "\n",
    "\t\treturn bSearch(arr, i / 2 + 1, i - 1, x);\n",
    "\t}\n",
    "\n",
    "\tpublic static void main(String args[]) \n",
    "    {\n",
    "\n",
    "\t\tint arr[] = {1, 2, 3, 40, 50};\n",
    "\n",
    "\t\tint x = 4;\n",
    "\n",
    "        System.out.println(search(arr, x));\n",
    "\n",
    "\n",
    "    } \n",
    "\n",
    "}\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "search in sorted array\n",
    "naive\n",
    "import java.util.*;\n",
    "import java.io.*;\n",
    "import java.lang.*;\n",
    "\n",
    "\n",
    "\n",
    "class GFG \n",
    "{ \n",
    "\n",
    "\tstatic int search(int arr[], int n, int x)\n",
    "\t{\n",
    "\t\tfor(int i = 0; i < n; i++)\n",
    "\t\t\tif(arr[i] == x)\n",
    "\t\t\t\treturn i;\n",
    "\n",
    "\t\treturn -1;\n",
    "\t}\n",
    "\n",
    "\tpublic static void main(String args[]) \n",
    "    {\n",
    "\n",
    "\t\tint arr[] = {100, 200, 400, 1000, 10, 20}, n = 6;\n",
    "\n",
    "\t\tint x = 10;\n",
    "\n",
    "        System.out.println(search(arr, n, x));\n",
    "\n",
    "    } \n",
    "\n",
    "}\n",
    "Efficient\n",
    "import java.util.*;\n",
    "import java.io.*;\n",
    "import java.lang.*;\n",
    "\n",
    "\n",
    "\n",
    "class GFG \n",
    "{ \n",
    "\n",
    "\tstatic int search(int arr[], int n, int x)\n",
    "\t{\n",
    "\t\tint low = 0, high = n - 1;\n",
    "\n",
    "\t\twhile(low <= high)\n",
    "\t\t{\n",
    "\t\t\tint mid = (low + high) / 2;\n",
    "\n",
    "\t\t\tif(arr[mid] == x)\n",
    "\t\t\t\treturn mid;\n",
    "\t\t\tif(arr[low] < arr[mid])\n",
    "\t\t\t{\n",
    "\t\t\t\tif(x >= arr[low] && x < arr[mid])\n",
    "\t\t\t\t\thigh = mid - 1;\n",
    "\t\t\t\telse \n",
    "\t\t\t\t\tlow = mid + 1;\n",
    "\t\t\t}\n",
    "\t\t\telse\n",
    "\t\t\t{\n",
    "\t\t\t\tif(x > arr[mid] && x <= arr[high])\n",
    "\t\t\t\t\tlow = mid + 1;\n",
    "\t\t\t\telse\n",
    "\t\t\t\t\thigh = mid - 1;\n",
    "\t\t\t}\n",
    "\t\t}\n",
    "\t\t\n",
    "\n",
    "\t\treturn -1;\n",
    "\t}\n",
    "\n",
    "\tpublic static void main(String args[]) \n",
    "    {\n",
    "\n",
    "\t\tint arr[] = {10, 20, 40, 60, 5, 8}, n = 6;\n",
    "\n",
    "\t\tint x = 5;\n",
    "\n",
    "        System.out.println(search(arr, n, x));\n",
    "\n",
    "    } \n",
    "\n",
    "}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "find peak element\n",
    "naive\n",
    "import java.util.*;\n",
    "import java.io.*;\n",
    "import java.lang.*;\n",
    "\n",
    "\n",
    "\n",
    "class GFG \n",
    "{ \n",
    "\n",
    "\tstatic int getPeak(int arr[], int n)\n",
    "\t{\n",
    "\t\tif(n == 1)\n",
    "\t\t\treturn arr[0];\n",
    "\t\tif(arr[0] >= arr[1])\n",
    "\t\t\treturn arr[0];\n",
    "\t\tif(arr[n - 1] >= arr[n - 2])\n",
    "\t\t\treturn arr[n - 1];\n",
    "\n",
    "\t\tfor(int i = 1; i < n - 1; i++)\n",
    "\t\t\tif(arr[i] >= arr[i - 1] && arr[i] >= arr[i + 1])\n",
    "\t\t\t\treturn arr[i];\n",
    "\t\t\t\t\n",
    "\t\treturn -1;\n",
    "\t}\n",
    "\n",
    "\tpublic static void main(String args[]) \n",
    "    {\n",
    "\n",
    "\t\tint arr[] = {5, 10, 11, 12, 20, 12}, n = 6;\n",
    "\n",
    "        System.out.println(getPeak(arr, n));\n",
    "\n",
    "    } \n",
    "\n",
    "}\n",
    "Efficient\n",
    "import java.util.*;\n",
    "import java.io.*;\n",
    "import java.lang.*;\n",
    "\n",
    "\n",
    "\n",
    "class GFG \n",
    "{ \n",
    "\n",
    "\tstatic int getPeak(int arr[], int n)\n",
    "\t{\n",
    "\t\tint low = 0, high = n - 1;\n",
    "\n",
    "\t\twhile(low <= high)\n",
    "\t\t{\n",
    "\t\t\tint mid = (low + high) / 2;\n",
    "\n",
    "\t\t\tif((mid == 0 || arr[mid - 1] <= arr[mid]) &&\n",
    "\t\t\t\t(mid == n - 1 || arr[mid + 1] <= arr[mid]))\n",
    "\t\t\t\treturn mid;\n",
    "\t\t\tif(mid > 0 && arr[mid - 1] >= arr[mid])\n",
    "\t\t\t\thigh = mid -1;\n",
    "\t\t\telse\n",
    "\t\t\t\tlow = mid + 1;\n",
    "\t\t}\n",
    "\t\t\n",
    "\t\treturn -1;\n",
    "\t}\n",
    "\n",
    "\tpublic static void main(String args[]) \n",
    "    {\n",
    "\n",
    "\t\tint arr[] = {5, 20, 40, 30, 20, 50, 60}, n = 7;\n",
    "\n",
    "        System.out.println(getPeak(arr, n));\n",
    "\n",
    "    } \n",
    "\n",
    "}\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "Two pointer approach\n",
    "\n",
    "1.Find pair in unsorted array which gives sum X\n",
    "// Java implementation using Hashing \n",
    "import java.io.*; \n",
    "import java.util.HashSet; \n",
    "\n",
    "class PairSum { \n",
    "\tstatic void printpairs(int arr[], int sum) \n",
    "\t{ \n",
    "\t\tHashSet<Integer> s = new HashSet<Integer>(); \n",
    "\t\tfor (int i = 0; i < arr.length; ++i) { \n",
    "\t\t\tint temp = sum - arr[i]; \n",
    "\n",
    "\t\t\t// checking for condition \n",
    "\t\t\tif (s.contains(temp)) { \n",
    "\t\t\t\tSystem.out.println(\"Pair with given sum \" + sum + \" is (\" + arr[i] + \", \" + temp + \")\"); \n",
    "\t\t\t} \n",
    "\t\t\ts.add(arr[i]); \n",
    "\t\t} \n",
    "\t} \n",
    "\n",
    "\t// Main to test the above function \n",
    "\tpublic static void main(String[] args) \n",
    "\t{ \n",
    "\t\tint A[] = { 1, 4, 45, 6, 10, 8 }; \n",
    "\t\tint n = 16; \n",
    "\t\tprintpairs(A, n); \n",
    "\t} \n",
    "} \n",
    "\n",
    "2.Find pair in sorted array which gives sum X\n",
    "import java.util.*;\n",
    "import java.io.*;\n",
    "import java.lang.*;\n",
    "\n",
    "class Solution\n",
    "{\n",
    "    static int isPresent(int arr[], int n, int sum)\n",
    "    {\n",
    "        int l = 0, h = n-1;\n",
    "        \n",
    "        \n",
    "        while(l <= h)\n",
    "        {\n",
    "            if(arr[l] + arr[h] == sum)\n",
    "              return 1;\n",
    "            else if(arr[l] + arr[h] > sum)\n",
    "                h--;\n",
    "            else l++;\n",
    "        }\n",
    "        \n",
    "        return 0;\n",
    "    }\n",
    "    public static void main (String[] args) {\n",
    "        int arr[] = new int[]{2, 3, 7, 8, 11};\n",
    "        int n = arr.length;\n",
    "        int sum = 14;\n",
    "        \n",
    "        System.out.println(isPresent(arr, n, sum));\n",
    "        \n",
    "    }\n",
    "}\n",
    "3.Find triplet in an array which gives sum X\n",
    "// Java program to find a triplet \n",
    "class FindTriplet { \n",
    "\n",
    "\t// returns true if there is triplet with sum equal \n",
    "\t// to 'sum' present in A[]. Also, prints the triplet \n",
    "\tboolean find3Numbers(int A[], int arr_size, int sum) \n",
    "\t{ \n",
    "\t\tint l, r; \n",
    "\n",
    "\t\t/* Sort the elements */\n",
    "\t\tquickSort(A, 0, arr_size - 1); \n",
    "\n",
    "\t\t/* Now fix the first element one by one and find the \n",
    "\t\tother two elements */\n",
    "\t\tfor (int i = 0; i < arr_size - 2; i++) { \n",
    "\n",
    "\t\t\t// To find the other two elements, start two index variables \n",
    "\t\t\t// from two corners of the array and move them toward each \n",
    "\t\t\t// other \n",
    "\t\t\tl = i + 1; // index of the first element in the remaining elements \n",
    "\t\t\tr = arr_size - 1; // index of the last element \n",
    "\t\t\twhile (l < r) { \n",
    "\t\t\t\tif (A[i] + A[l] + A[r] == sum) { \n",
    "\t\t\t\t\tSystem.out.print(\"Triplet is \" + A[i] + \", \" + A[l] + \", \" + A[r]); \n",
    "\t\t\t\t\treturn true; \n",
    "\t\t\t\t} \n",
    "\t\t\t\telse if (A[i] + A[l] + A[r] < sum) \n",
    "\t\t\t\t\tl++; \n",
    "\n",
    "\t\t\t\telse // A[i] + A[l] + A[r] > sum \n",
    "\t\t\t\t\tr--; \n",
    "\t\t\t} \n",
    "\t\t} \n",
    "\n",
    "\t\t// If we reach here, then no triplet was found \n",
    "\t\treturn false; \n",
    "\t} \n",
    "\n",
    "\tint partition(int A[], int si, int ei) \n",
    "\t{ \n",
    "\t\tint x = A[ei]; \n",
    "\t\tint i = (si - 1); \n",
    "\t\tint j; \n",
    "\n",
    "\t\tfor (j = si; j <= ei - 1; j++) { \n",
    "\t\t\tif (A[j] <= x) { \n",
    "\t\t\t\ti++; \n",
    "\t\t\t\tint temp = A[i]; \n",
    "\t\t\t\tA[i] = A[j]; \n",
    "\t\t\t\tA[j] = temp; \n",
    "\t\t\t} \n",
    "\t\t} \n",
    "\t\tint temp = A[i + 1]; \n",
    "\t\tA[i + 1] = A[ei]; \n",
    "\t\tA[ei] = temp; \n",
    "\t\treturn (i + 1); \n",
    "\t} \n",
    "\n",
    "\t/* Implementation of Quick Sort \n",
    "\tA[] --> Array to be sorted \n",
    "\tsi --> Starting index \n",
    "\tei --> Ending index \n",
    "\t*/\n",
    "\tvoid quickSort(int A[], int si, int ei) \n",
    "\t{ \n",
    "\t\tint pi; \n",
    "\n",
    "\t\t/* Partitioning index */\n",
    "\t\tif (si < ei) { \n",
    "\t\t\tpi = partition(A, si, ei); \n",
    "\t\t\tquickSort(A, si, pi - 1); \n",
    "\t\t\tquickSort(A, pi + 1, ei); \n",
    "\t\t} \n",
    "\t} \n",
    "\n",
    "\t// Driver program to test above functions \n",
    "\tpublic static void main(String[] args) \n",
    "\t{ \n",
    "\t\tFindTriplet triplet = new FindTriplet(); \n",
    "\t\tint A[] = { 1, 4, 45, 6, 10, 8 }; \n",
    "\t\tint sum = 22; \n",
    "\t\tint arr_size = A.length; \n",
    "\n",
    "\t\ttriplet.find3Numbers(A, arr_size, sum); \n",
    "\t} \n",
    "} \n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "Median of two sorted arrays\n",
    "\n",
    "import java.util.*;\n",
    "import java.io.*;\n",
    "import java.lang.*;\n",
    "\n",
    "\n",
    "\n",
    "class GFG \n",
    "{ \n",
    "\n",
    "\tstatic double getMed(int a1[], int a2[], int n1, int n2)\n",
    "\t{\n",
    "\t\tint begin1 = 0, end1 = n1;\n",
    "\n",
    "\t\twhile(begin1 < end1)\n",
    "\t\t{\n",
    "\t\t\tint i1 = (begin1 + end1) / 2;\n",
    "\t\t\tint i2 = ((n1 + n2 + 1) / 2 )- i1;\n",
    "\n",
    "\t\t\tint min1 = (i1 == n1)?Integer.MAX_VALUE:a1[i1];\n",
    "\t\t\tint max1 = (i1 == 0)?Integer.MIN_VALUE:a1[i1 - 1];\n",
    "\t\t\t\n",
    "\t\t\tint min2 = (i2 == n2)?Integer.MAX_VALUE:a2[i2];\n",
    "\t\t\tint max2 = (i2 == 0)?Integer.MIN_VALUE:a2[i2 - 1];\n",
    "\n",
    "\t\t\tif(max1 <= min2 && max2 <= min1)\n",
    "\t\t\t{\n",
    "\t\t\t\tif((n1 + n2) % 2 == 0)\n",
    "\t\t\t\t\treturn ((double)Math.max(max1, max2) + Math.min(min1, min2)) / 2;\n",
    "\t\t\t\telse\n",
    "\t\t\t\t\treturn (double) Math.max(max1, max2);\n",
    "\t\t\t}\n",
    "\t\t\telse if(max1 > min2)\n",
    "\t\t\t\tend1 = i1 - 1;\n",
    "\t\t\telse \n",
    "\t\t\t\tbegin1 = i1 + 1;\n",
    "\t\t}\n",
    "\t\t\n",
    "\t\treturn -1;\n",
    "\t}\n",
    "\n",
    "\tpublic static void main(String args[]) \n",
    "    {\n",
    "\n",
    "\t\tint a1[] = {10, 20, 30, 40, 50}, n1 = 5, a2[] = {5, 15, 25, 35, 45}, n2 = 5;\n",
    "\t\t\n",
    "        System.out.println(getMed(a1, a2, n1, n2));\n",
    "\n",
    "\n",
    "    } \n",
    "\n",
    "}\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "Repeating element 1\n",
    "import java.util.*;\n",
    "import java.io.*;\n",
    "import java.lang.*;\n",
    "\n",
    "\n",
    "\n",
    "class GFG \n",
    "{ \n",
    "\n",
    "\tstatic int repeat(int arr[], int n)\n",
    "\t{\n",
    "\t\tboolean visit[] = new boolean[n];\n",
    "\n",
    "\t\tfor(int i = 0; i < n; i++)\n",
    "\t\t{\n",
    "\t\t\tif(visit[arr[i]])\n",
    "\t\t\t\treturn arr[i];\n",
    "\t\t\tvisit[arr[i]] = true;\n",
    "\t\t}\n",
    "\n",
    "\t\treturn -1;\n",
    "\t}\n",
    "\n",
    "\tpublic static void main(String args[]) \n",
    "    {\n",
    "\n",
    "\t\tint arr[] = {0, 2, 1, 3, 2, 2}, n= 6;\n",
    "\n",
    "        System.out.println(repeat(arr, n));\n",
    "\n",
    "    } \n",
    "\n",
    "}\n",
    "Repeating element 2\n",
    "\n",
    "import java.util.*;\n",
    "import java.io.*;\n",
    "import java.lang.*;\n",
    "\n",
    "\n",
    "\n",
    "class GFG \n",
    "{ \n",
    "\n",
    "\tstatic int repeat(int arr[], int n)\n",
    "\t{\n",
    "\t\tint slow = arr[0], fast = arr[0];\n",
    "\n",
    "\t\tdo{\n",
    "\t\t\tslow = arr[slow];\n",
    "\t\t\tfast = arr[arr[fast]];\n",
    "\t\t\n",
    "\t\t}while(slow != fast);\n",
    "\t\t\n",
    "\t\tslow = arr[0];\n",
    "\n",
    "\t\twhile(slow != fast)\n",
    "\t\t{\n",
    "\t\t\tslow = arr[slow];\n",
    "\t\t\tfast = arr[fast];\n",
    "\t\t}\n",
    "\t\treturn slow;\n",
    "\t}\n",
    "\n",
    "\tpublic static void main(String args[]) \n",
    "    {\n",
    "\n",
    "\t\tint arr[] = {1, 3, 2, 4, 6, 5, 7, 3}, n= 8;\n",
    "\n",
    "        System.out.println(repeat(arr, n));\n",
    "\n",
    "    } \n",
    "\n",
    "}\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "Sorting"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "Bubble Sorting\n",
    "/*package whatever //do not write package name here */\n",
    "\n",
    "import java.io.*;\n",
    "\n",
    "class GFG {\n",
    "    \n",
    "    static void bubbleSort(int arr[], int n){\n",
    "        for(int i = 0; i < n; i++){\n",
    "            for(int j = 0; j < n - i - 1; j++){\n",
    "                if( arr[j] > arr[j + 1]){\n",
    "                    \n",
    "                    // swapping\n",
    "                    int temp = arr[j];\n",
    "                    arr[j] = arr[j+1];\n",
    "                    arr[j+1] = temp;\n",
    "                    \n",
    "                }\n",
    "            }\n",
    "        }\n",
    "    }\n",
    "    \n",
    "\tpublic static void main (String[] args) {\n",
    "\t    int a[] = {2, 1, 4, 3};\n",
    "\t    bubbleSort(a, 4);\n",
    "\t    \n",
    "\t    for(int i = 0; i < 4; i++){\n",
    "\t        System.out.print(a[i] + \" \");\n",
    "\t    }\n",
    "\t}\n",
    "}\n",
    "optimized\n",
    "/*package whatever //do not write package name here */\n",
    "\n",
    "import java.io.*;\n",
    "\n",
    "class GFG {\n",
    "    \n",
    "    static void bubbleSort(int arr[], int n){\n",
    "        boolean swapped;\n",
    "        \n",
    "        for(int i = 0; i < n; i++){\n",
    "            \n",
    "            swapped = false;\n",
    "            \n",
    "            for(int j = 0; j < n - i - 1; j++){\n",
    "                if( arr[j] > arr[j + 1]){\n",
    "                    \n",
    "                    // swapping\n",
    "                    int temp = arr[j];\n",
    "                    arr[j] = arr[j+1];\n",
    "                    arr[j+1] = temp;\n",
    "                    \n",
    "                    swapped = true;\n",
    "                    \n",
    "                }\n",
    "            }\n",
    "            if(swapped == false)\n",
    "            break;\n",
    "        }\n",
    "    }\n",
    "    \n",
    "\tpublic static void main (String[] args) {\n",
    "\t    int a[] = {2, 1, 4, 3};\n",
    "\t    bubbleSort(a, 4);\n",
    "\t    \n",
    "\t    for(int i = 0; i < 4; i++){\n",
    "\t        System.out.print(a[i] + \" \");\n",
    "\t    }\n",
    "\t}\n",
    "}\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "selection sort\n",
    "/*package whatever //do not write package name here */\n",
    "\n",
    "import java.io.*;\n",
    "\n",
    "class GFG {\n",
    "    \n",
    "    \n",
    "    static void selectionSort(int arr[], int n){\n",
    "        for(int i = 0; i < n; i++){\n",
    "            int min_ind = i;\n",
    "            \n",
    "            for(int j = i + 1; j < n; j++){\n",
    "                if(arr[j] < arr[min_ind]){\n",
    "                    min_ind = j;\n",
    "                }\n",
    "            }\n",
    "            \n",
    "            int temp = arr[i];\n",
    "            arr[i] = arr[min_ind];\n",
    "            arr[min_ind] = temp;\n",
    "        }\n",
    "    }\n",
    "    \n",
    "    \n",
    "\tpublic static void main (String[] args) {\n",
    "\t    int a[] = {2, 1, 4, 3};\n",
    "\t    selectionSort(a, 4);\n",
    "\t    \n",
    "\t    for(int i = 0; i < 4; i++){\n",
    "\t        System.out.print(a[i] + \" \");\n",
    "\t    }\n",
    "\t}\n",
    "}\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "Insertion sort \n",
    "import java.util.*;\n",
    "import java.lang.*;\n",
    "import java.io.*;\n",
    "\n",
    "class Solution\n",
    "{\n",
    "    public static void main (String[] args) \n",
    "    {\n",
    "        int arr[] = new int[]{50,20,40,60,10,30};\n",
    "        \n",
    "        int n = arr.length;\n",
    "        iSort(arr,n);\n",
    "        \n",
    "        for(int x:arr)\n",
    "            System.out.print(x+\" \");\n",
    "        \n",
    "    }\n",
    "    \n",
    "    static void iSort(int arr[],int n){\n",
    "    \n",
    "        for(int i=1;i<n;i++){\n",
    "            int key = arr[i];\n",
    "            int j=i-1;\n",
    "            while(j>=0 && arr[j]>key){\n",
    "                arr[j+1]=arr[j];\n",
    "                j--;\n",
    "            }\n",
    "            arr[j+1]=key;\n",
    "        }\n",
    "    }\n",
    "}\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "merge two sorted array\n",
    "naive\n",
    "import java.util.*;\n",
    "import java.lang.*;\n",
    "import java.io.*;\n",
    "\n",
    "class Solution\n",
    "{\n",
    "    public static void main (String[] args) \n",
    "    {\n",
    "        int a[] = new int[]{10,15,20,40};\n",
    "        int b[] = new int[]{5,6,6,10,15};\n",
    "        \n",
    "        int m = a.length;\n",
    "        int n = b.length;\n",
    "        merge(a,b,m,n);\n",
    "        \n",
    "    }\n",
    "    \n",
    "    static void merge(int a[], int b[], int m, int n){\n",
    "    \n",
    "        int[] c=new int[m+n];\n",
    "        for(int i=0;i<m;i++)\n",
    "            c[i]=a[i];\n",
    "        for(int j=0;j<n;j++)\n",
    "            c[j+m]=b[j];\n",
    "        \n",
    "        Arrays.sort(c);\n",
    "        \n",
    "        for(int i=0;i<m+n;i++)\n",
    "            System.out.print(c[i]+\" \");\n",
    "    }\n",
    "}\n",
    "efficicent\n",
    "import java.util.*;\n",
    "import java.lang.*;\n",
    "import java.io.*;\n",
    "\n",
    "class Solution\n",
    "{\n",
    "    public static void main (String[] args) \n",
    "    {\n",
    "        int a[] = new int[]{10,15,20,40};\n",
    "        int b[] = new int[]{5,6,6,10,15};\n",
    "        \n",
    "        int m = a.length;\n",
    "        int n = b.length;\n",
    "        merge(a,b,m,n);\n",
    "        \n",
    "    }\n",
    "    \n",
    "    static void merge(int a[], int b[], int m, int n){\n",
    "    \n",
    "        int i=0,j=0;\n",
    "        while(i<m && j<n){\n",
    "            if(a[i]<b[j])\n",
    "                System.out.print(a[i++]+\" \");\n",
    "            else\n",
    "                System.out.print(b[j++]+\" \");\n",
    "        }\n",
    "        while(i<m)\n",
    "            System.out.print(a[i++]+\" \");\n",
    "        while(j<n)\n",
    "            System.out.print(b[j++]+\" \");    \n",
    "    }\n",
    "}\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "merge sort\n",
    "import java.util.*;\n",
    "import java.lang.*;\n",
    "import java.io.*;\n",
    "\n",
    "class Solution\n",
    "{\n",
    "    public static void main (String[] args) \n",
    "    {\n",
    "        int a[] = new int[]{10,5,30,15,7};\n",
    "\t    int l=0,r=4;\n",
    "        \n",
    "        mergeSort(a,l,r);\n",
    "    \tfor(int x: a)\n",
    "\t        System.out.print(x+\" \");\n",
    "        \n",
    "    }\n",
    "    \n",
    "    static void merge(int arr[], int l, int m, int h){\n",
    "    \n",
    "        int n1=m-l+1, n2=h-m;\n",
    "        int[] left=new int[n1];int[]right=new int[n2];\n",
    "        for(int i=0;i<n1;i++)\n",
    "            left[i]=arr[i+l];\n",
    "        for(int j=0;j<n2;j++)\n",
    "            right[j]=arr[m+1+j];    \n",
    "        int i=0,j=0,k=l;\n",
    "        while(i<n1 && j<n2){\n",
    "            if(left[i]<=right[j])\n",
    "                arr[k++]=left[i++];\n",
    "            else\n",
    "                arr[k++]=right[j++];\n",
    "        }\n",
    "        while(i<n1)\n",
    "            arr[k++]=left[i++];\n",
    "        while(j<n2)\n",
    "            arr[k++]=right[j++];    \n",
    "    }\n",
    "    \n",
    "    static void mergeSort(int arr[],int l,int r){\n",
    "        if(r>l){\n",
    "            int m=l+(r-l)/2;\n",
    "            mergeSort(arr,l,m);\n",
    "            mergeSort(arr,m+1,r);\n",
    "            merge(arr,l,m,r);\n",
    "        }\n",
    "    }\n",
    "}\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "intersection of two sorted arr\n",
    "naive\n",
    "\n",
    "import java.util.*;\n",
    "import java.lang.*;\n",
    "import java.io.*;\n",
    "\n",
    "class Solution\n",
    "{\n",
    "    public static void main (String[] args) \n",
    "    {\n",
    "        int a[] = new int[]{3,5,10,10,10,15,15,20};\n",
    "        int b[] = new int[]{5,10,10,15,30};\n",
    "        \n",
    "        int m = a.length;\n",
    "        int n = b.length;\n",
    "\t    intersection(a,b,m,n);\n",
    "        \n",
    "    }\n",
    "    \n",
    "    static void intersection(int a[], int b[], int m, int n){\n",
    "    \n",
    "        for(int i=0;i<m;i++){\n",
    "            if(i>0 && a[i-1]==a[i])\n",
    "                continue;\n",
    "            for(int j=0;j<n;j++)\n",
    "                if(a[i]==b[j]){\n",
    "                    System.out.print(a[i]+\" \");\n",
    "                    break;\n",
    "                }\n",
    "        }    \n",
    "    }\n",
    "}\n",
    "efficient\n",
    "import java.util.*;\n",
    "import java.lang.*;\n",
    "import java.io.*;\n",
    "\n",
    "class Solution\n",
    "{\n",
    "    public static void main (String[] args) \n",
    "    {\n",
    "        int a[] = new int[]{3,5,10,10,10,15,15,20};\n",
    "        int b[] = new int[]{5,10,10,15,30};\n",
    "        \n",
    "        int m = a.length;\n",
    "        int n = b.length;\n",
    "\t    intersection(a,b,m,n);\n",
    "        \n",
    "    }\n",
    "    \n",
    "    static void intersection(int a[], int b[], int m, int n){\n",
    "    \n",
    "         int i=0,j=0;\n",
    "        while(i<m && j<n){\n",
    "            if(i>0 && a[i-1]==a[i]){\n",
    "                i++;\n",
    "                continue;\n",
    "            }\n",
    "            if(a[i]<b[j]){\n",
    "                i++;\n",
    "            }\n",
    "            else if(a[i]>b[j]){\n",
    "                j++;\n",
    "            }\n",
    "            else{\n",
    "                System.out.print(a[i]+\" \");\n",
    "                i++;j++;\n",
    "            }\n",
    "        }   \n",
    "    }\n",
    "}\n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "union of two sorted array\n",
    "\n",
    "naive\n",
    "import java.util.*;\n",
    "import java.lang.*;\n",
    "import java.io.*;\n",
    "\n",
    "class Solution\n",
    "{\n",
    "    public static void main (String[] args) \n",
    "    {\n",
    "        int a[] = new int[]{3,8,10};\n",
    "        int b[] = new int[]{2,8,9,10,15};\n",
    "        \n",
    "        int m = a.length;\n",
    "        int n = b.length;\n",
    "\t    printUnion(a,b,m,n);\n",
    "        \n",
    "    }\n",
    "    \n",
    "    static void printUnion(int a[], int b[], int m, int n){\n",
    "    \n",
    "        int[] c=new int[m+n];\n",
    "        for(int i=0;i<m;i++)\n",
    "            c[i]=a[i];\n",
    "        for(int i=0;i<n;i++)\n",
    "            c[i+m]=b[i];\n",
    "        Arrays.sort(c);\n",
    "        \n",
    "        for(int i=0;i<m+n;i++){\n",
    "            if(i==0||c[i]!=c[i-1])\n",
    "                System.out.print(c[i]+\" \");\n",
    "        }\n",
    "    }\n",
    "}\n",
    "\n",
    "efficient\n",
    "\n",
    "import java.util.*;\n",
    "import java.lang.*;\n",
    "import java.io.*;\n",
    "\n",
    "class Solution\n",
    "{\n",
    "    public static void main (String[] args) \n",
    "    {\n",
    "        int a[] = new int[]{3,8,8};\n",
    "        int b[] = new int[]{2,8,8,10,15};\n",
    "        \n",
    "        int m = a.length;\n",
    "        int n = b.length;\n",
    "\t    printUnion(a,b,m,n);\n",
    "        \n",
    "    }\n",
    "    \n",
    "    static void printUnion(int a[], int b[], int m, int n){\n",
    "    \n",
    "        int i=0,j=0;\n",
    "        while(i<m && j<n){\n",
    "            if(i>0 && a[i-1]==a[i]){i++;continue;}\n",
    "            if(j>0 && b[j-1]==b[j]){j++;continue;}\n",
    "            if(a[i]<b[j]){System.out.print(a[i]+\" \");i++;}\n",
    "            else if(a[i]>b[j]){System.out.print(b[j]+\" \");j++;}\n",
    "            else{System.out.print(a[i]+\" \");i++;j++;}\n",
    "        }\n",
    "            while(i<m){if(i==0||a[i]!=a[i-1])System.out.print(a[i]+\" \");i++;}\n",
    "            while(j<n){if(j==0||b[j]!=b[j-1])System.out.print(b[j]+\" \");j++;}\n",
    "    }\n",
    "}\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "quick sor\n",
    "import java.util.*;\n",
    "import java.lang.*;\n",
    "import java.io.*;\n",
    "\n",
    "class Solution\n",
    "{\n",
    "    public static void main (String[] args) \n",
    "    {\n",
    "        int arr[] = new int[]{8,4,7,9,3,10,5};\n",
    "        \n",
    "        int n = arr.length;\n",
    "        qSort(arr,0,n-1);\n",
    "        \n",
    "\t    for(int x: arr)\n",
    "\t        System.out.print(x+\" \");\n",
    "        \n",
    "    }\n",
    "    \n",
    "    static int iPartition(int arr[], int l, int h)\n",
    "    {   \n",
    "        int pivot=arr[h];\n",
    "        int i=l-1;\n",
    "        for(int j=l;j<=h-1;j++){\n",
    "            if(arr[j]<pivot){\n",
    "                i++;\n",
    "                int temp=arr[i];\n",
    "                arr[i]=arr[j];\n",
    "                arr[j]=temp;\n",
    "            }\n",
    "        }\n",
    "        int temp=arr[i+1];\n",
    "        arr[i+1]=arr[h];\n",
    "        arr[h]=temp;\n",
    "        return i+1;\n",
    "    }\n",
    "    \n",
    "    static void qSort(int arr[],int l,int h){\n",
    "        if(l<h){\n",
    "            int p=iPartition(arr,l,h);\n",
    "            qSort(arr,l,p-1);\n",
    "            qSort(arr,p+1,h);\n",
    "        }\n",
    "    }\n",
    "}\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "kth smallest element\n",
    "naive\n",
    "import java.util.*;\n",
    "import java.lang.*;\n",
    "import java.io.*;\n",
    "\n",
    "class Solution\n",
    "{\n",
    "    public static void main (String[] args) \n",
    "    {\n",
    "        int arr[] = new int[]{10,5,30,12};\n",
    "        \n",
    "        int n = arr.length;int k=2;\n",
    "        \n",
    "\t    System.out.print(kthSmallest(arr,n,k));\n",
    "        \n",
    "    }\n",
    "    \n",
    "    static int kthSmallest(int arr[], int n, int k)\n",
    "    {   \n",
    "        Arrays.sort(arr);\n",
    "        return arr[k-1];\n",
    "    }\n",
    "}\n",
    "efficient\n",
    "import java.util.*;\n",
    "import java.lang.*;\n",
    "import java.io.*;\n",
    "\n",
    "class Solution\n",
    "{\n",
    "    public static void main (String[] args) \n",
    "    {\n",
    "        int arr[] = new int[]{10,4,5,8,11,6,26};\n",
    "        \n",
    "        int n = arr.length;int k=5;\n",
    "        int index=kthSmallest(arr,n,k);\n",
    "        \n",
    "        System.out.print(arr[index]);\n",
    "        \n",
    "    }\n",
    "    \n",
    "    static int partition(int arr[], int l, int h)\n",
    "    {   \n",
    "        int pivot=arr[h];\n",
    "        int i=l-1;\n",
    "        for(int j=l;j<=h-1;j++){\n",
    "            if(arr[j]<pivot){\n",
    "                i++;\n",
    "                int temp=arr[i];\n",
    "                arr[i]=arr[j];\n",
    "                arr[j]=temp;\n",
    "            }\n",
    "        }\n",
    "        int temp=arr[i+1];\n",
    "        arr[i+1]=arr[h];\n",
    "        arr[h]=temp;\n",
    "        return i+1;\n",
    "    }\n",
    "    \n",
    "    static int kthSmallest(int arr[],int n,int k){\n",
    "        int l=0,r=n-1;\n",
    "        while(l<=r){\n",
    "            int p=partition(arr,l,r);\n",
    "            if(p==k-1)\n",
    "                return p;\n",
    "            else if(p>k-1)\n",
    "                r=p-1;\n",
    "            else\n",
    "                l=p+1;\n",
    "        }\n",
    "        return -1;\n",
    "    }\n",
    "}\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "heap sort \n",
    "import java.util.*;\n",
    "import java.io.*;\n",
    "import java.lang.*;\n",
    "  \n",
    "public class HeapSort \n",
    "{ \n",
    "\tpublic void buildheap(int arr[],int n){\n",
    "        for (int i = n / 2 - 1; i >= 0; i--) \n",
    "\t\t    heapify(arr, n, i);\n",
    "    }\n",
    "\t\n",
    "\tpublic void sort(int arr[]) \n",
    "\t{ \n",
    "\t\tint n = arr.length; \n",
    "\n",
    "\t\tbuildheap(arr,n); \n",
    " \n",
    "\t\tfor (int i=n-1; i>0; i--) \n",
    "\t\t{ \n",
    "\t\t\t \n",
    "\t\t\tint temp = arr[0]; \n",
    "\t\t\tarr[0] = arr[i]; \n",
    "\t\t\tarr[i] = temp; \n",
    "\n",
    "\t\t\theapify(arr, i, 0); \n",
    "\t\t} \n",
    "\t} \n",
    "\n",
    "\tvoid heapify(int arr[], int n, int i) \n",
    "\t{ \n",
    "\t\tint largest = i;  \n",
    "\t\tint l = 2*i + 1; \n",
    "\t\tint r = 2*i + 2; \n",
    "\n",
    "\t\tif (l < n && arr[l] > arr[largest]) \n",
    "\t\t\tlargest = l; \n",
    " \n",
    "\t\tif (r < n && arr[r] > arr[largest]) \n",
    "\t\t\tlargest = r; \n",
    "\n",
    "\t\tif (largest != i) \n",
    "\t\t{ \n",
    "\t\t\tint swap = arr[i]; \n",
    "\t\t\tarr[i] = arr[largest]; \n",
    "\t\t\tarr[largest] = swap; \n",
    "\n",
    "\t\t\theapify(arr, n, largest); \n",
    "\t\t} \n",
    "\t} \n",
    "\n",
    "\tstatic void printArray(int arr[]) \n",
    "\t{ \n",
    "\t\tint n = arr.length; \n",
    "\t\tfor (int i=0; i<n; ++i) \n",
    "\t\t\tSystem.out.print(arr[i]+\" \"); \n",
    "\t\tSystem.out.println(); \n",
    "\t} \n",
    " \n",
    "\tpublic static void main(String args[]) \n",
    "\t{ \n",
    "\t\tint arr[] = {12, 11, 13, 5, 6, 7}; \n",
    "\t\tint n = arr.length; \n",
    "\n",
    "\t\tHeapSort ob = new HeapSort(); \n",
    "\t\tob.sort(arr); \n",
    "\n",
    "\t\tSystem.out.println(\"Sorted array is\"); \n",
    "\t\tprintArray(arr); \n",
    "\t} \n",
    "} \n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "buckets sort\n",
    "import java.util.*;\n",
    "import java.lang.*;\n",
    "import java.io.*;\n",
    "\n",
    "class Solution\n",
    "{\n",
    "    public static void main (String[] args) \n",
    "    {\n",
    "        int arr[] = { 30,40,10,80,5,12,70 };\n",
    "        int n = arr.length; int k=4;\n",
    "        bucketSort(arr, n, k); \n",
    "   \n",
    "        for (int i = 0; i < n; i++) \n",
    "            System.out.print( arr[i] + \" \");\n",
    "        \n",
    "    }\n",
    "    \n",
    "    static void bucketSort(int arr[], int n, int k) { \n",
    "        \n",
    "        int max_val=arr[0];\n",
    "        for(int i=1;i<n;i++)\n",
    "            max_val=Math.max(max_val,arr[i]); \n",
    "        max_val++;\n",
    "        \n",
    "        @SuppressWarnings(\"unchecked\") \n",
    "        Vector<Integer>[] buckets = new Vector[n]; \n",
    "  \n",
    "        for (int i = 0; i < n; i++) { \n",
    "            buckets[i] = new Vector<Integer>(); \n",
    "        } \n",
    "   \n",
    "        for (int i = 0; i < n; i++) { \n",
    "            int idx = (arr[i] * k)/max_val; \n",
    "            buckets[(int)idx].add(arr[i]); \n",
    "        } \n",
    "  \n",
    "        for (int i = 0; i < k; i++) { \n",
    "            Collections.sort(buckets[i]); \n",
    "        } \n",
    "  \n",
    "        int index = 0; \n",
    "        for (int i = 0; i < k; i++) { \n",
    "            for (int j = 0; j < buckets[i].size(); j++) { \n",
    "                arr[index++] = buckets[i].get(j); \n",
    "            } \n",
    "        } \n",
    "    }\n",
    "}\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "2 D matrix\n",
    "\n",
    "Naive\n",
    "import java.util.*;\n",
    "import java.io.*;\n",
    "import java.lang.*;\n",
    "\n",
    "\n",
    "\n",
    "class GFG \n",
    "{ \n",
    "\tstatic int n = 4;\n",
    "\n",
    "\tstatic void rotate90(int mat[][])\n",
    "\t{\n",
    "\t\tint temp[][] = new int[n][n];\n",
    "\n",
    "\t\tfor(int i = 0; i < n; i++)\n",
    "\t\t\tfor(int j = 0; j < n; j++)\n",
    "\t\t\t\ttemp[n - j - 1][i] = mat[i][j];\n",
    "\n",
    "\t\tfor(int i = 0; i < n; i++)\n",
    "\t\t\tfor(int j = 0; j < n; j++)\n",
    "\t\t\t\tmat[i][j] = temp[i][j];\n",
    "\n",
    "\t}\n",
    "\n",
    "\tpublic static void main(String args[]) \n",
    "    {\n",
    "        int arr[][] = {{1, 2, 3, 4},\n",
    "    \t\t\t\t   {5, 6, 7, 8},\n",
    "    \t\t\t\t   {9, 10, 11, 12},\n",
    "    \t\t\t\t   {13, 14, 15, 16}};\n",
    "\n",
    "    \trotate90(arr);\n",
    "\n",
    "\t\tfor(int i = 0; i < n; i++)\n",
    "\t\t{\n",
    "\t\t\tfor(int j = 0; j < n; j++)\n",
    "\t\t\t{\n",
    "\t\t\t\tSystem.out.print(arr[i][j]+\" \");\n",
    "\t\t\t}\n",
    "\n",
    "\t\t\tSystem.out.println();\n",
    "\t\t}\t\n",
    "    } \n",
    "\n",
    "}\n",
    "Efficient\n",
    "import java.util.*;\n",
    "import java.io.*;\n",
    "import java.lang.*;\n",
    "\n",
    "\n",
    "\n",
    "class GFG \n",
    "{ \n",
    "\tstatic int n = 4;\n",
    "\n",
    "\tstatic void swap(int mat[][], int i, int j)\n",
    "\t{\n",
    "\t\t\tint temp = mat[i][j];\n",
    "\t\t\tmat[i][j] = mat[j][i];\n",
    "\t\t\tmat[j][i] = temp;\n",
    "\t}\n",
    "\t\n",
    "\tstatic void swap2(int low, int high, int i, int mat[][])\n",
    "\t{\n",
    "\t    \tint temp = mat[low][i];\n",
    "\t\t\tmat[low][i] = mat[high][i];\n",
    "\t\t\tmat[high][i] = temp;\n",
    "\t}\n",
    "\n",
    "\tstatic void rotate90(int mat[][])\n",
    "\t{\n",
    "\n",
    "\t\tfor(int i = 0; i < n; i++)\n",
    "\t\t\tfor(int j = i + 1; j < n; j++)\n",
    "\t\t\t\tswap(mat, i, j);\n",
    "\t\t\t\t\n",
    "\t\tfor(int i = 0; i < n; i++)\n",
    "\t\t{\n",
    "\t\t    int low = 0, high = n - 1;\n",
    "\t\t    \n",
    "\t\t    while(low < high)\n",
    "\t\t    {\n",
    "\t\t        swap2(low, high, i, mat);\n",
    "\t\t        \n",
    "\t\t        low++;\n",
    "\t\t        high--;\n",
    "\t\t    }\n",
    "\t\t}\n",
    "\t}\n",
    "\n",
    "\tpublic static void main(String args[]) \n",
    "    {\n",
    "        int arr[][] = {{1, 2, 3, 4},\n",
    "    \t\t\t\t   {5, 6, 7, 8},\n",
    "    \t\t\t\t   {9, 10, 11, 12},\n",
    "    \t\t\t\t   {13, 14, 15, 16}};\n",
    "\n",
    "    \trotate90(arr);\n",
    "\n",
    "    \t\tfor(int i = 0; i < n; i++)\n",
    "\t\t\t{\n",
    "\t\t\t\tfor(int j = 0; j < n; j++)\n",
    "\t\t\t\t{\n",
    "\t\t\t\t\tSystem.out.print(arr[i][j]+\" \");\n",
    "\t\t\t\t}\n",
    "\n",
    "\t\t\t\tSystem.out.println();\n",
    "\t\t\t}\t\n",
    "    } \n",
    "\n",
    "}\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "spiral matrix\n",
    "import java.util.*;\n",
    "import java.io.*;\n",
    "import java.lang.*;\n",
    "\n",
    "\n",
    "\n",
    "class GFG \n",
    "{ \n",
    "\t\n",
    "\n",
    "\tstatic void printSpiral(int mat[][], int R, int C)\n",
    "\t{\n",
    "\t\tint top = 0, left = 0, bottom = R - 1, right = C - 1;\n",
    "\n",
    "\t\twhile(top <= bottom && left <= right)\n",
    "\t\t{\n",
    "\t\t\tfor(int i = left; i <= right; i++)\n",
    "\t\t\t\tSystem.out.print(mat[top][i] + \" \");\n",
    "\n",
    "\t\t\ttop++;\n",
    "\n",
    "\t\t\tfor(int i = top; i <= bottom; i++)\n",
    "\t\t\t\tSystem.out.print(mat[i][right] + \" \");\n",
    "\t\t\t\n",
    "\t\t\tright--;\n",
    "\n",
    "\t\t\tif(top <= bottom){\n",
    "\t\t\tfor(int i = right; i >= left; i--)\n",
    "\t\t\t\tSystem.out.print(mat[bottom][i] + \" \");\n",
    "\n",
    "\t\t\tbottom--;\n",
    "\t\t\t}\n",
    "\n",
    "\t\t\tif(left <= right){\n",
    "\t\t\tfor(int i = bottom; i >= top; i--)\n",
    "\t\t\t\tSystem.out.print(mat[i][left] + \" \");\n",
    "\n",
    "\t\t\tleft++;\n",
    "\t\t\t}\t\t\t\n",
    "\t\t}\n",
    "\t}\n",
    "\n",
    "\tpublic static void main(String args[]) \n",
    "    {\n",
    "        int arr[][] = {{1, 2, 3, 4},\n",
    "    \t\t\t\t   {5, 6, 7, 8},\n",
    "    \t\t\t\t   {9, 10, 11, 12},\n",
    "    \t\t\t\t   {13, 14, 15, 16}};\n",
    "\n",
    "    \tprintSpiral(arr, 4, 4);\n",
    "\n",
    "\t\t\n",
    "    } \n",
    "\n",
    "}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "search in row-wise and column-wise sort \n",
    "naive\n",
    "import java.util.*;\n",
    "import java.io.*;\n",
    "import java.lang.*;\n",
    "\n",
    "\n",
    "\n",
    "class GFG \n",
    "{ \n",
    "\t\n",
    "\tstatic int R = 4, C = 4;\n",
    "\n",
    "\tstatic void search(int mat[][], int x)\n",
    "\t{\n",
    "\t\tfor(int i = 0; i < R; i++)\n",
    "\t\t{\n",
    "\t\t\tfor(int j = 0; j < C; j++)\n",
    "\t\t\t{\n",
    "\t\t\t\tif(mat[i][j] == x)\n",
    "\t\t\t\t{\n",
    "\t\t\t\t\tSystem.out.println(\"Found at (\" + i + \", \" + j + \")\");\n",
    "\t\t\t\t\t\n",
    "\t\t\t\t\treturn;\n",
    "\t\t\t\t}\n",
    "\t\t\t}\n",
    "\t\t}\n",
    "\n",
    "\t\tSystem.out.println(\"Not Found\");\n",
    "\t}\n",
    "\n",
    "\tpublic static void main(String args[]) \n",
    "    {\n",
    "        int arr[][] = {{10, 20, 30, 40},\n",
    "    \t\t\t\t   {15, 25, 35, 45},\n",
    "    \t\t\t\t   {27, 29, 35, 45},\n",
    "    \t\t\t\t   {32, 33, 39, 50}};\n",
    "    \tint x = 29;\t   \n",
    "\n",
    "    \tsearch(arr, x);\n",
    "\n",
    "\t\t\n",
    "    } \n",
    "\n",
    "}\n",
    "import java.util.*;\n",
    "import java.io.*;\n",
    "import java.lang.*;\n",
    "\n",
    "\n",
    "\n",
    "class GFG \n",
    "{ \n",
    "\t\n",
    "\tstatic int R = 4, C = 4;\n",
    "\n",
    "\tstatic void search(int mat[][], int x)\n",
    "\t{\n",
    "\t\tint i  = 0, j = C - 1;\n",
    "\n",
    "\t\twhile(i < R && j >= 0)\n",
    "\t\t{\n",
    "\t\t\tif(mat[i][j] == x)\n",
    "\t\t\t{\n",
    "\t\t\t\tSystem.out.println(\"Found at (\" + i + \", \" + j + \")\");\n",
    "\t\t\t\treturn;\n",
    "\t\t\t}\n",
    "\t\t\telse if(mat[i][j] > x)\n",
    "\t\t\t{\n",
    "\t\t\t\tj--;\n",
    "\t\t\t}\n",
    "\t\t\telse\n",
    "\t\t\t{\n",
    "\t\t\t\ti++;\n",
    "\t\t\t}\n",
    "\t\t}\n",
    "\t\tSystem.out.println(\"Not Found\");\n",
    "\t}\n",
    "\n",
    "\tpublic static void main(String args[]) \n",
    "    {\n",
    "        int arr[][] = {{10, 20, 30, 40},\n",
    "    \t\t\t\t   {15, 25, 35, 45},\n",
    "    \t\t\t\t   {27, 29, 35, 45},\n",
    "    \t\t\t\t   {32, 33, 39, 50}};\n",
    "    \tint x = 29;\t   \n",
    "\n",
    "    \tsearch(arr, x);\n",
    "\n",
    "\t\t\n",
    "    } \n",
    "\n",
    "}\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "median of a row wise sorted\n",
    "import java.util.Arrays;\n",
    "\n",
    "public class MedianInRowSorted\n",
    "{\n",
    "static public int matMed(int mat[][], int r ,int c)\n",
    "{\n",
    "\tint min = mat[0][0], max = mat[0][c-1];\n",
    "\tfor (int i=1; i<r; i++)\n",
    "\t{\n",
    "\t\tif (mat[i][0] < min)\n",
    "\t\t\tmin = mat[i][0];\n",
    "\n",
    "\t\tif (mat[i][c-1] > max)\n",
    "\t\t\tmax = mat[i][c-1];\n",
    "\t}\n",
    "\n",
    "\tint medPos = (r * c + 1) / 2;\n",
    "\twhile (min < max)\n",
    "\t{\n",
    "\t\tint mid = (min + max) / 2;\n",
    "\t\tint midPos = 0;\n",
    "        int pos = 0;\n",
    "\t\tfor (int i = 0; i < r; ++i){\n",
    "\t\t\t    pos = Arrays.binarySearch(mat[i],mid);\n",
    "                \n",
    "                if(pos < 0)\n",
    "                    pos = Math.abs(pos) - 1;\n",
    "                  \n",
    "                \n",
    "                else\n",
    "                {\n",
    "                    while(pos < mat[i].length && mat[i][pos] == mid)\n",
    "                        pos += 1;\n",
    "                }\n",
    "                  \n",
    "                midPos = midPos + pos;\n",
    "\t\t}\n",
    "\t\tif (midPos < medPos)\n",
    "\t\t\tmin = mid + 1;\n",
    "\t\telse\n",
    "\t\t\tmax = mid;\n",
    "\t}\n",
    "\treturn min;\n",
    "}\n",
    "\n",
    "public static void main(String[] args)\n",
    "{\n",
    "\tint r = 3, c = 5;\n",
    "\tint m[][]= { {5,10,20,30,40}, {1,2,3,4,6}, {11,13,15,17,19} };\n",
    "\tSystem.out.println(\"Median is \" + matMed(m, r, c)); \n",
    "\t\n",
    "}\n",
    "}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "Hashset in java\n",
    "// Java program to demonstrate \n",
    "// working of HashSet \n",
    "import java.util.*; \n",
    "\n",
    "class Test \n",
    "{ \n",
    "    public static void main(String[]args) \n",
    "    { \n",
    "        HashSet<String> h = new HashSet<String>(); \n",
    "\n",
    "        \n",
    "        h.add(\"gfg\"); \n",
    "        h.add(\"courses\"); \n",
    "        h.add(\"ide\"); \n",
    "\n",
    "      \n",
    "        System.out.println(h);\n",
    "        \n",
    "        \n",
    "        System.out.println(h.contains(\"ide\"));\n",
    "        \n",
    "       \n",
    "        Iterator<String> i = h.iterator();\n",
    "        \n",
    "        while(i.hasNext())\n",
    "        {\n",
    "            System.out.print(i.next()+\" \");\n",
    "        }\n",
    "        \n",
    "        \n",
    "    } \n",
    "} \n",
    "// Java program to demonstrate \n",
    "// working of HashSet \n",
    "import java.util.*; \n",
    "\n",
    "class Test \n",
    "{ \n",
    "    public static void main(String[]args) \n",
    "    { \n",
    "        HashSet<String> h = new HashSet<String>(); \n",
    "\n",
    "        \n",
    "        h.add(\"gfg\"); \n",
    "        h.add(\"courses\"); \n",
    "        h.add(\"ide\"); \n",
    "\n",
    "      \n",
    "        System.out.println(h.size());\n",
    "        \n",
    "        h.remove(\"ide\");\n",
    "        System.out.println(h.size());\n",
    "        \n",
    "        for(String s: h)\n",
    "        {\n",
    "            System.out.print(s+\" \");\n",
    "        }\n",
    "        \n",
    "        \n",
    "        \n",
    "        System.out.println(\"\\n\"+h.isEmpty());\n",
    "        \n",
    "    } \n",
    "} \n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "HashMap\n",
    "// Java program to illustrate \n",
    "// Java.util.HashMap \n",
    "\n",
    "import java.util.HashMap; \n",
    "import java.util.Map;\n",
    "\n",
    "public class GFG { \n",
    "    public static void main(String[] args) \n",
    "    { \n",
    "        // Create an empty hash map \n",
    "        HashMap<String, Integer> m  = new HashMap<>(); \n",
    "\n",
    "        // Add elements to the map \n",
    "        m.put(\"gfg\", 10); \n",
    "        m.put(\"ide\", 15); \n",
    "        m.put(\"courses\", 20); \n",
    "\n",
    "        // Print size and content\n",
    "        System.out.println(m); \n",
    "        System.out.println(m.size()); \n",
    "        \n",
    "        // Iterating over HashMap \n",
    "        for(Map.Entry<String, Integer>e : m.entrySet())\n",
    "            System.out.println(e.getKey() + \" \" + e.getValue());\n",
    "    } \n",
    "} \n",
    "// Java program to illustrate \n",
    "// Java.util.HashMap \n",
    "\n",
    "import java.util.HashMap; \n",
    "import java.util.Map;\n",
    "\n",
    "public class GFG { \n",
    "    public static void main(String[] args) \n",
    "    { \n",
    "        // Create an empty hash map \n",
    "        HashMap<String, Integer> m \n",
    "            = new HashMap<>(); \n",
    "\n",
    "        // Add elements to the map \n",
    "        m.put(\"gfg\", 10); \n",
    "        m.put(\"ide\", 15); \n",
    "        m.put(\"courses\", 20); \n",
    "\n",
    "        // Check for a key\n",
    "        if (m.containsKey(\"ide\")) \n",
    "            System.out.println(\"Yes\");\n",
    "        else\n",
    "            System.out.println(\"No\");\n",
    "        \n",
    "        // Remove key \"ide\"\n",
    "        // and returns the associated value 15\n",
    "        m.remove(\"ide\");\n",
    "        System.out.println(m.size());\n",
    "    } \n",
    "} \n",
    "// Java program to illustrate \n",
    "// Java.util.HashMap \n",
    "\n",
    "import java.util.HashMap; \n",
    "import java.util.Map;\n",
    "\n",
    "public class GFG { \n",
    "    public static void main(String[] args) \n",
    "    { \n",
    "        // Create an empty hash map \n",
    "        HashMap<String, Integer> m \n",
    "            = new HashMap<>(); \n",
    "\n",
    "        // Add elements to the map \n",
    "        m.put(\"gfg\", 10); \n",
    "        m.put(\"ide\", 15); \n",
    "        m.put(\"courses\", 20); \n",
    "\n",
    "        // Check for a Value\n",
    "        if (m.containsValue(15)) \n",
    "            System.out.println(\"Yes\");\n",
    "        else\n",
    "            System.out.println(\"No\");\n",
    "        \n",
    "        // Get value corresponding to passed key\n",
    "        // <\"ide\", 15>\n",
    "        System.out.println(m.get(\"ide\"));\n",
    "        \n",
    "        // The given key is absent\n",
    "        System.out.println(m.get(\"practice\"));\n",
    "        \n",
    "    } \n",
    "} \n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "count distinct elements\n",
    "import java.util.*;\n",
    "import java.io.*;\n",
    "import java.lang.*;\n",
    "\n",
    "class Distinct\n",
    "{\n",
    "    public static void main (String[] args) {\n",
    "        int arr[] = new int[]{15, 16, 27, 27, 28, 15};\n",
    "        int n = arr.length;\n",
    "        \n",
    "        System.out.println(countDistinct(arr, n));\n",
    "    }\n",
    "    \n",
    "    static int countDistinct(int arr[], int n)\n",
    "    {\n",
    "        Set<Integer> hs = new HashSet<Integer>();\n",
    "        for(int i = 0; i < n; i++)\n",
    "          hs.add(arr[i]);\n",
    "    \n",
    "       return hs.size();        \n",
    "    }\n",
    "}\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "frquency of array elements\n",
    "import java.util.*;\n",
    "import java.io.*;\n",
    "import java.lang.*;\n",
    "\n",
    "class Distinct\n",
    "{\n",
    "    public static void main (String[] args) {\n",
    "        int arr[] = new int[]{15, 16, 27, 27, 28, 15};\n",
    "        int n = arr.length;\n",
    "        \n",
    "        countFreq(arr, n);\n",
    "    }\n",
    "    \n",
    "    static void countFreq(int arr[], int n)\n",
    "    {\n",
    "        Map<Integer, Integer> hmp = new HashMap<Integer, Integer>();\n",
    "        for(int i = 0; i < n; i++)\n",
    "        {\n",
    "            int key = arr[i];\n",
    "            if(hmp.containsKey(arr[i]) == true)\n",
    "              hmp.put(arr[i], hmp.get(arr[i]) + 1);\n",
    "            else\n",
    "              hmp.put(arr[i], 1);    \n",
    "        }\n",
    "    \n",
    "       for(Map.Entry<Integer, Integer> itr: hmp.entrySet())\n",
    "        System.out.println(itr.getKey() + \" \" + itr.getValue());\n",
    "    }\n",
    "}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "String"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "check if a string is subsequence of other\n",
    "iterative\n",
    "/*package whatever //do not write package name here */\n",
    "\n",
    "import java.util.*;\n",
    "\n",
    "class GFG {\n",
    "    \n",
    "    static boolean isSubSeq(String s1, String s2, int n, int m){\n",
    "        int j = 0;\n",
    "        for(int i = 0; i < n && j < m; i++){\n",
    "            if(s1.charAt(i) == s2.charAt(j))\n",
    "            j++;\n",
    "        }\n",
    "        \n",
    "        return j == m;\n",
    "    }\n",
    "    \n",
    "\tpublic static void main (String[] args) {\n",
    "\t\tScanner sc = new Scanner(System.in);\n",
    "\t\tint n, m;\n",
    "\t\tn = sc.nextInt();\n",
    "\t\tm = sc.nextInt();\n",
    "\t\t\n",
    "\t\tString s1, s2;\n",
    "\t\ts1 = sc.next();\n",
    "\t\ts2 = sc.next();\n",
    "\t\t\n",
    "\t\tSystem.out.println(isSubSeq(s1, s2, n, m));\n",
    "\t\t\n",
    "\t}\n",
    "}\n",
    "recurssive\n",
    "/*package whatever //do not write package name here */\n",
    "\n",
    "import java.util.*;\n",
    "\n",
    "class GFG {\n",
    "    \n",
    "    static boolean isSubSeq(String s1, String s2, int n, int m){\n",
    "        if( m == 0 )\n",
    "            return true;\n",
    "        \n",
    "        if( n == 0 )\n",
    "            return false;\n",
    "            \n",
    "        if ( s1.charAt(n-1) == s2.charAt(m-1) )\n",
    "            return isSubSeq(s1, s2, n-1, m-1);\n",
    "        \n",
    "        else\n",
    "            return isSubSeq(s1, s2, n-1, m);\n",
    "    }\n",
    "    \n",
    "\tpublic static void main (String[] args) {\n",
    "\t\tScanner sc = new Scanner(System.in);\n",
    "\t\tint n, m;\n",
    "\t\tn = sc.nextInt();\n",
    "\t\tm = sc.nextInt();\n",
    "\t\t\n",
    "\t\tString s1, s2;\n",
    "\t\ts1 = sc.next();\n",
    "\t\ts2 = sc.next();\n",
    "\t\t\n",
    "\t\tSystem.out.println(isSubSeq(s1, s2, n, m));\n",
    "\t\t\n",
    "\t}\n",
    "}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "panagram\n",
    "naive\n",
    "import java.util.*;\n",
    "import java.io.*;\n",
    "import java.lang.*;\n",
    "  \n",
    "class GFG { \n",
    "  \n",
    "    static boolean areAnagram(String s1, String s2) \n",
    "    { \n",
    "       \n",
    "        if (s1.length() != s2.length()) \n",
    "            return false; \n",
    "  \n",
    "       char a1[]=s1.toCharArray();\n",
    "        Arrays.sort(a1);\n",
    "        s1=new String(a1);\n",
    "        char a2[]=s2.toCharArray();\n",
    "        Arrays.sort(a2);\n",
    "        s2=new String(a2);\n",
    "        \n",
    "        return s1.equals(s2);\n",
    "    } \n",
    "  \n",
    "    public static void main(String args[]) \n",
    "    { \n",
    "        String str1 = \"abaac\"; \n",
    "        String str2 = \"aacba\";  \n",
    "        if (areAnagram(str1, str2)) \n",
    "            System.out.println(\"The two strings are\"\n",
    "                               + \" anagram of each other\"); \n",
    "        else\n",
    "            System.out.println(\"The two strings are not\"\n",
    "                               + \" anagram of each other\"); \n",
    "    } \n",
    "} \n",
    "efficient\n",
    "import java.util.*;\n",
    "import java.io.*;\n",
    "import java.lang.*;\n",
    "  \n",
    "class GFG { \n",
    "    \n",
    "    static final int CHAR=256;\n",
    "        \n",
    "    static boolean areAnagram(String s1, String s2) \n",
    "    { \n",
    "       \n",
    "        if (s1.length() != s2.length()) \n",
    "            return false; \n",
    "  \n",
    "       int[] count=new int[CHAR];\n",
    "    for(int i=0;i<s1.length();i++){\n",
    "        count[s1.charAt(i)]++;\n",
    "        count[s2.charAt(i)]--;\n",
    "    }\n",
    "    \n",
    "    for(int i=0;i<CHAR;i++){\n",
    "        if(count[i]!=0)return false;\n",
    "    }\n",
    "    return true;\n",
    "    } \n",
    "  \n",
    "    public static void main(String args[]) \n",
    "    { \n",
    "        String str1 = \"abaac\"; \n",
    "        String str2 = \"aacba\";  \n",
    "        if (areAnagram(str1, str2)) \n",
    "            System.out.println(\"The two strings are\"\n",
    "                               + \" anagram of each other\"); \n",
    "        else\n",
    "            System.out.println(\"The two strings are not\"\n",
    "                               + \" anagram of each other\"); \n",
    "    } \n",
    "} "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "reverse words in a string\n",
    "import java.util.*;\n",
    "import java.io.*;\n",
    "import java.lang.*;\n",
    "  \n",
    "class GFG { \n",
    "       \n",
    "    static void reverse(char str[],int low, int high){\n",
    "    while(low<=high){\n",
    "        //swap\n",
    "        char temp=str[low];\n",
    "        str[low]=str[high];\n",
    "        str[high]=temp;\n",
    "        //\n",
    "        low++;\n",
    "        high--;\n",
    "    }\n",
    "    }\n",
    "\n",
    "    static void reverseWords(char str[],int n){\n",
    "    int start=0;\n",
    "    for(int end=0;end<n;end++){\n",
    "        if(str[end]==' '){\n",
    "            reverse(str,start,end-1);\n",
    "            start=end+1;\n",
    "        }\n",
    "    }\n",
    "    reverse(str,start,n-1);\n",
    "    reverse(str,0,n-1);\n",
    "    }\n",
    "  \n",
    "    public static void main(String args[]) \n",
    "    {   String s = \"Welcome to Gfg\";int n=s.length();\n",
    "        char[] str = s.toCharArray();\n",
    "        System.out.println(\"After reversing words in the string:\");\n",
    "        reverseWords(str,n);\n",
    "        System.out.println(str);  \n",
    "    } \n",
    "} "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "Linked List\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "simple implementation linkedlist\n",
    "import java.util.*;\n",
    "import java.io.*;\n",
    "import java.lang.*;\n",
    "  \n",
    "class GFG { \n",
    "    \n",
    "    static class Node{\n",
    "        int data;\n",
    "        Node next;\n",
    "        Node(int x){\n",
    "            data=x;\n",
    "            next=null;\n",
    "        }\n",
    "    }\n",
    "    static Node insertBegin(Node head, int x){\n",
    "        Node temp=new Node(x);\n",
    "        temp.next=head;\n",
    "        return temp;\n",
    "    }\n",
    "    \n",
    "    \n",
    "    static Node delHead(Node head){\n",
    "        if(head==null)return null;\n",
    "        else{\n",
    "            return head.next;\n",
    "    }\n",
    "        \n",
    "    static Node delTail(Node head){\n",
    "        if(head==null)return null;\n",
    "        if(head.next==null)return null;\n",
    "        Node curr=head;\n",
    "        while(curr.next.next!=null)\n",
    "            curr=curr.next;\n",
    "        curr.next=null;\n",
    "        return head;\n",
    "    }\n",
    "     \n",
    "    \n",
    "    static Node insertEnd(Node head, int x){\n",
    "        Node temp=new Node(x);\n",
    "        if(head==null)return temp;\n",
    "        Node curr=head;\n",
    "        while(curr.next!=null){\n",
    "            curr=curr.next;\n",
    "        }\n",
    "        curr.next=temp;\n",
    "        return head;\n",
    "    }\n",
    "    \n",
    "    static int search(Node head, int x){\n",
    "        int pos=1;\n",
    "        Node curr=head;\n",
    "        while(curr!=null){\n",
    "            if(curr.data==x)\n",
    "                return pos;\n",
    "            else{\n",
    "                pos++;\n",
    "                curr=curr.next;\n",
    "            }\n",
    "        }\n",
    "        return -1;\n",
    "    }\n",
    "    // recursive\n",
    "    static int search(Node head, int x){\n",
    "        if(head==null)return -1;\n",
    "        if(head.data==x)return 1;\n",
    "        else{\n",
    "            int res=search(head.next,x);\n",
    "            if(res==-1)return -1;\n",
    "            else return res+1;\n",
    "        }\n",
    "    }\n",
    "    \n",
    "    public static void printlist(Node head){\n",
    "        Node curr=head;\n",
    "        while(curr!=null){\n",
    "        System.out.print(curr.data+\" \");\n",
    "        curr=curr.next;\n",
    "    }\n",
    "    \n",
    "    public static void main(String args[]) \n",
    "    { \n",
    "        Node head=new Node(10);\n",
    "    \tNode temp1=new Node(20);\n",
    "    \tNode temp2=new Node(30);\n",
    "    \thead.next=temp1;\n",
    "    \ttemp1.next=temp2;\n",
    "    \tSystem.out.print(head.data+\"-->\"+temp1.data+\"-->\"+temp2.data);\n",
    "    \t\n",
    "    } \n",
    "} "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "LRU design\n",
    "import java.util.*;\n",
    "import java.io.*;\n",
    "import java.lang.*;\n",
    "import java.util.*; \n",
    "\n",
    "class Node { \n",
    "\tint key; \n",
    "\tint value; \n",
    "\tNode pre; \n",
    "\tNode next; \n",
    "\n",
    "\tpublic Node(int key, int value) \n",
    "\t{ \n",
    "\t\tthis.key = key; \n",
    "\t\tthis.value = value; \n",
    "\t} \n",
    "} \n",
    "\n",
    "class LRUCache { \n",
    "\tprivate HashMap<Integer, Node> map; \n",
    "\tprivate int capacity, count; \n",
    "\tprivate Node head, tail; \n",
    "\n",
    "\tpublic LRUCache(int capacity) \n",
    "\t{ \n",
    "\t\tthis.capacity = capacity; \n",
    "\t\tmap = new HashMap<>(); \n",
    "\t\thead = new Node(0, 0); \n",
    "\t\ttail = new Node(0, 0); \n",
    "\t\thead.next = tail; \n",
    "\t\ttail.pre = head; \n",
    "\t\thead.pre = null; \n",
    "\t\ttail.next = null; \n",
    "\t\tcount = 0; \n",
    "\t} \n",
    "\n",
    "\tpublic void deleteNode(Node node) \n",
    "\t{ \n",
    "\t\tnode.pre.next = node.next; \n",
    "\t\tnode.next.pre = node.pre; \n",
    "\t} \n",
    "\n",
    "\tpublic void addToHead(Node node) \n",
    "\t{ \n",
    "\t\tnode.next = head.next; \n",
    "\t\tnode.next.pre = node; \n",
    "\t\tnode.pre = head; \n",
    "\t\thead.next = node; \n",
    "\t} \n",
    " \n",
    "\tpublic int get(int key) \n",
    "\t{ \n",
    "\t\tif (map.get(key) != null) { \n",
    "\t\t\tNode node = map.get(key); \n",
    "\t\t\tint result = node.value; \n",
    "\t\t\tdeleteNode(node); \n",
    "\t\t\taddToHead(node); \n",
    "\t\t\tSystem.out.println(\"Got the value : \" + \n",
    "\t\t\t\tresult + \" for the key: \" + key); \n",
    "\t\t\treturn result; \n",
    "\t\t} \n",
    "\t\tSystem.out.println(\"Did not get any value\" + \n",
    "\t\t\t\t\t\t\t\" for the key: \" + key); \n",
    "\t\treturn -1; \n",
    "\t} \n",
    "\n",
    "\tpublic void set(int key, int value) \n",
    "\t{ \n",
    "\t\tSystem.out.println(\"Going to set the (key, \"+ \n",
    "\t\t\t\"value) : (\" + key + \", \" + value + \")\"); \n",
    "\t\tif (map.get(key) != null) { \n",
    "\t\t\tNode node = map.get(key); \n",
    "\t\t\tnode.value = value; \n",
    "\t\t\tdeleteNode(node); \n",
    "\t\t\taddToHead(node); \n",
    "\t\t} \n",
    "\t\telse { \n",
    "\t\t\tNode node = new Node(key, value); \n",
    "\t\t\tmap.put(key, node); \n",
    "\t\t\tif (count < capacity) { \n",
    "\t\t\t\tcount++; \n",
    "\t\t\t\taddToHead(node); \n",
    "\t\t\t} \n",
    "\t\t\telse { \n",
    "\t\t\t\tmap.remove(tail.pre.key); \n",
    "\t\t\t\tdeleteNode(tail.pre); \n",
    "\t\t\t\taddToHead(node); \n",
    "\t\t\t} \n",
    "\t\t} \n",
    "\t} \n",
    "} \n",
    "\n",
    "public class TestLRUCache { \n",
    "\tpublic static void main(String[] args) \n",
    "\t{ \n",
    "\t\t\n",
    "\t\tLRUCache cache = new LRUCache(2); \n",
    "\n",
    "\t\t// it will store a key (1) with value \n",
    "\t\t// 10 in the cache. \n",
    "\t\tcache.set(1, 10); \n",
    "\n",
    "\t\t// it will store a key (2) with value 20 in the cache. \n",
    "\t\tcache.set(2, 20); \n",
    "\t\tSystem.out.println(\"Value for the key: 1 is \" + cache.get(1)); // returns 10 \n",
    "\n",
    "\t\t// removing key 2 and store a key (3) with value 30 in the cache. \n",
    "\t\tcache.set(3, 30); \n",
    "\n",
    "\t\tSystem.out.println(\"Value for the key: 2 is \" + \n",
    "\t\t\t\tcache.get(2)); // returns -1 (not found) \n",
    "\n",
    "\t\t// removing key 1 and store a key (4) with value 40 in the cache. \n",
    "\t\tcache.set(4, 40); \n",
    "\t\tSystem.out.println(\"Value for the key: 1 is \" + \n",
    "\t\t\tcache.get(1)); // returns -1 (not found) \n",
    "\t\tSystem.out.println(\"Value for the key: 3 is \" + \n",
    "\t\t\t\t\t\tcache.get(3)); // returns 30 \n",
    "\t\tSystem.out.println(\"Value for the key: 4 is \" + \n",
    "\t\t\t\t\t\tcache.get(4)); // return 40 \n",
    "\t} \n",
    "} \n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "merge two linked list\n",
    "import java.util.*;\n",
    "import java.io.*;\n",
    "import java.lang.*;\n",
    "\n",
    "class Node{\n",
    "        int data;\n",
    "        Node next;\n",
    "        Node(int x){\n",
    "            data=x;\n",
    "            next=null;\n",
    "        }\n",
    "    }\n",
    "  \n",
    "class Test { \n",
    "    \n",
    "    public static void main(String args[]) \n",
    "    { \n",
    "        Node a=new Node(10);\n",
    "    \ta.next=new Node(20);\n",
    "    \ta.next.next=new Node(30);\n",
    "    \tNode b=new Node(5);\n",
    "    \tb.next=new Node(35);\n",
    "    \tprintlist(sortedMerge(a,b));\n",
    "    \t\n",
    "    } \n",
    "    \n",
    "    static Node sortedMerge(Node a,Node b){\n",
    "        if(a==null)return b;\n",
    "        if(b==null)return a;\n",
    "        Node head=null,tail=null;\n",
    "        if(a.data<=b.data){\n",
    "            head=tail=a;a=a.next;\n",
    "        }\n",
    "        else{\n",
    "            head=tail=b;b=b.next;\n",
    "        }\n",
    "        while(a!=null&&b!=null){\n",
    "            if(a.data<=b.data){\n",
    "                tail.next=a;tail=a;a=a.next;\n",
    "            }\n",
    "            else{\n",
    "                tail.next=b;tail=b;b=b.next;\n",
    "            }\n",
    "        }\n",
    "        if(a==null){tail.next=b;}\n",
    "        else{\n",
    "            tail.next=a;\n",
    "        }\n",
    "        return head;\n",
    "    }\n",
    "    \n",
    "    public static void printlist(Node head){\n",
    "        Node curr=head;\n",
    "        while(curr!=null){\n",
    "        System.out.print(curr.data+\" \");\n",
    "        curr=curr.next;\n",
    "    }System.out.println();\n",
    "    }\n",
    "} "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "palindrome llist\n",
    "naive\n",
    "import java.util.*;\n",
    "import java.io.*;\n",
    "import java.lang.*;\n",
    "\n",
    "class Node{\n",
    "        char data;\n",
    "        Node next;\n",
    "        Node(char x){\n",
    "            data=x;\n",
    "            next=null;\n",
    "        }\n",
    "    }\n",
    "  \n",
    "class Test { \n",
    "    \n",
    "    public static void main(String args[]) \n",
    "    { \n",
    "        Node head=new Node('g');\n",
    "    \thead.next=new Node('f');\n",
    "    \thead.next.next=new Node('g');\n",
    "    \tif(isPalindrome(head))\n",
    "    \t    System.out.print(\"Yes\");\n",
    "    \telse\n",
    "    \t    System.out.print(\"No\");\n",
    "    \t\n",
    "    } \n",
    "    \n",
    "    static boolean isPalindrome(Node head){\n",
    "        Deque<Character> stack=new ArrayDeque<Character>();\n",
    "        for(Node curr=head;curr!=null;curr=curr.next)\n",
    "            stack.push(curr.data);\n",
    "        for(Node curr=head;curr!=null;curr=curr.next){\n",
    "            if(stack.pop()!=curr.data)\n",
    "                return false;\n",
    "        }\n",
    "        return true;\n",
    "    }\n",
    "} \n",
    "efficient\n",
    "\n",
    "import java.util.*;\n",
    "import java.io.*;\n",
    "import java.lang.*;\n",
    "\n",
    "class Node{\n",
    "        char data;\n",
    "        Node next;\n",
    "        Node(char x){\n",
    "            data=x;\n",
    "            next=null;\n",
    "        }\n",
    "    }\n",
    "  \n",
    "class Test { \n",
    "    \n",
    "    public static void main(String args[]) \n",
    "    { \n",
    "        Node head=new Node('g');\n",
    "    \thead.next=new Node('f');\n",
    "    \thead.next.next=new Node('g');\n",
    "    \tif(isPalindrome(head))\n",
    "    \t    System.out.print(\"Yes\");\n",
    "    \telse\n",
    "    \t    System.out.print(\"No\");\n",
    "    \t\n",
    "    } \n",
    "    \n",
    "    static Node reverseList(Node head){\n",
    "        if(head==null||head.next==null)return head;\n",
    "        Node rest_head=reverseList(head.next);\n",
    "        Node rest_tail=head.next;\n",
    "        rest_tail.next=head;\n",
    "        head.next=null;\n",
    "        return rest_head;\n",
    "    }\n",
    "    \n",
    "    static boolean isPalindrome(Node head){\n",
    "        if(head==null)return true;\n",
    "        Node slow=head,fast=head;\n",
    "        while(fast.next!=null&&fast.next.next!=null){\n",
    "            slow=slow.next;\n",
    "            fast=fast.next.next;\n",
    "        }\n",
    "        Node rev=reverseList(slow.next);\n",
    "        Node curr=head;\n",
    "        while(rev!=null){\n",
    "            if(rev.data!=curr.data)\n",
    "                return false;\n",
    "            rev=rev.next;\n",
    "            curr=curr.next;\n",
    "        }\n",
    "        return true;\n",
    "    }\n",
    "} \n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3.9.5 64-bit",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.5"
  },
  "orig_nbformat": 4,
  "vscode": {
   "interpreter": {
    "hash": "cbc5014ed32a3511c99c810aecedbd8e5a5c878610fa20b4667810c497ccaeea"
   }
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
